#!/bin/bash
# nbs-chat-terminal: Interactive terminal client for nbs-chat
#
# Displays a scrolling message view and accepts typed input.
# Lets humans participate in nbs-chat conversations alongside AI instances.
#
# Usage:
#   nbs-chat-terminal <file> <handle>
#
# Controls:
#   Type a message and press Enter to add a line.
#   Press Enter on an empty line to send the message.
#   Type /edit on an empty line to compose in $EDITOR.
#   Type /help for all commands.
#   Type /exit or Ctrl-C to exit.
#
# New messages from others are displayed each time you press Enter.
#
# Exit codes:
#   0 - Clean exit
#   1 - General error
#   2 - Chat file not found
#   4 - Invalid arguments

set -uo pipefail

# Resolve nbs-chat location (same directory as this script)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
NBS_CHAT="$SCRIPT_DIR/nbs-chat"

if [[ ! -x "$NBS_CHAT" ]]; then
    echo "Error: nbs-chat not found at $NBS_CHAT" >&2
    exit 1
fi

# --- Argument parsing ---

CHAT_FILE="${1:-}"
HANDLE="${2:-}"

if [[ -z "$CHAT_FILE" ]] || [[ -z "$HANDLE" ]]; then
    cat <<'USAGE'
nbs-chat-terminal: Interactive terminal client for nbs-chat

Usage:
  nbs-chat-terminal <file> <handle>

  <file>    Path to chat file (must exist, use 'nbs-chat create' first)
  <handle>  Your display name in the chat

Controls:
  Type a message and press Enter to add a line.
  Press Enter on an empty line to send the message.
  Type /edit on an empty line to compose in $EDITOR.
  Type /help for all commands.
  Type /exit or Ctrl-C to exit.

New messages from others are displayed each time you press Enter.

Example:
  nbs-chat create .nbs/chat/debug.chat
  nbs-chat-terminal .nbs/chat/debug.chat alex
USAGE
    exit 4
fi

if [[ ! -f "$CHAT_FILE" ]]; then
    echo "Error: Chat file not found: $CHAT_FILE" >&2
    echo "Create it first: nbs-chat create $CHAT_FILE" >&2
    exit 2
fi

# --- Colour assignment ---

# Palette of distinct colours (ANSI 256-colour codes)
COLOURS=(
    "38;5;39"    # Blue
    "38;5;208"   # Orange
    "38;5;41"    # Green
    "38;5;213"   # Pink
    "38;5;226"   # Yellow
    "38;5;87"    # Cyan
    "38;5;196"   # Red
    "38;5;147"   # Lavender
)
BOLD="\033[1m"
DIM="\033[2m"
RESET="\033[0m"

declare -A HANDLE_COLOURS
COLOUR_INDEX=0

get_colour() {
    local h="$1"
    if [[ -z "${HANDLE_COLOURS[$h]+x}" ]]; then
        HANDLE_COLOURS["$h"]="${COLOURS[$COLOUR_INDEX]}"
        COLOUR_INDEX=$(( (COLOUR_INDEX + 1) % ${#COLOURS[@]} ))
    fi
    echo "${HANDLE_COLOURS[$h]}"
}

# --- Display functions ---

format_message() {
    local msg="$1"
    # Extract handle and content
    local msg_handle msg_content
    msg_handle="${msg%%: *}"
    msg_content="${msg#*: }"

    local colour
    colour=$(get_colour "$msg_handle")

    if [[ "$msg_handle" == "$HANDLE" ]]; then
        # Own messages slightly dimmer
        echo -e "  ${DIM}\033[${colour}m${msg_handle}${RESET}${DIM}: ${msg_content}${RESET}"
    else
        echo -e "  \033[${colour}m${BOLD}${msg_handle}${RESET}: ${msg_content}"
    fi
}

print_prompt() {
    echo -en "${BOLD}${HANDLE}>${RESET} "
}

print_continuation() {
    echo -en "${DIM}...${RESET} "
}

# --- State ---

STATE_DIR=$(mktemp -d)
MSG_COUNT=0

# --- Cleanup ---

cleanup() {
    rm -rf "$STATE_DIR"
    stty echo 2>/dev/null
    echo ""
    echo -e "${DIM}Left chat.${RESET}"
    exit 0
}
trap cleanup INT TERM EXIT

# --- Check and display new messages ---
# Called in the foreground loop each time the user presses Enter.
# No background poller touches the screen — no clobbering.

check_new_messages() {
    local current
    current=$("$NBS_CHAT" read "$CHAT_FILE" 2>/dev/null)
    local current_count=0
    if [[ -n "$current" ]]; then
        current_count=$(echo "$current" | grep -c '.' || true)
    fi

    if [[ $current_count -gt $MSG_COUNT ]]; then
        local new_msgs
        new_msgs=$("$NBS_CHAT" read "$CHAT_FILE" --last=$((current_count - MSG_COUNT)) 2>/dev/null)

        MSG_COUNT=$current_count

        if [[ -n "$new_msgs" ]]; then
            while IFS= read -r line; do
                [[ -z "$line" ]] && continue

                local line_handle
                line_handle="${line%%: *}"

                # Skip own messages — already displayed when sent
                if [[ "$line_handle" == "$HANDLE" ]]; then
                    continue
                fi

                format_message "$line"
            done <<< "$new_msgs"
        fi
    fi
}

# --- Initial display ---

# Show existing messages
EXISTING=$("$NBS_CHAT" read "$CHAT_FILE" 2>/dev/null)
if [[ -n "$EXISTING" ]]; then
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        format_message "$line"
    done <<< "$EXISTING"
    MSG_COUNT=$(echo "$EXISTING" | grep -c '.' || true)
    echo ""
fi

# --- Editor mode ---

EDIT_TMPFILE=""

open_editor() {
    local editor="${EDITOR:-vim}"
    EDIT_TMPFILE=$(mktemp "${STATE_DIR}/edit.XXXXXX")

    # Run editor on /dev/tty so it gets the real terminal
    "$editor" "$EDIT_TMPFILE" </dev/tty >/dev/tty 2>/dev/tty
}

read_editor_result() {
    local content=""
    if [[ -n "$EDIT_TMPFILE" ]] && [[ -f "$EDIT_TMPFILE" ]] && [[ -s "$EDIT_TMPFILE" ]]; then
        content=$(cat "$EDIT_TMPFILE")
    fi
    if [[ -n "$EDIT_TMPFILE" ]]; then
        rm -f "$EDIT_TMPFILE"
        EDIT_TMPFILE=""
    fi
    echo "$content"
}

# --- Input loop ---

INPUT_BUFFER=""

while true; do
    # Check for new messages before showing prompt
    check_new_messages

    if [[ -z "$INPUT_BUFFER" ]]; then
        print_prompt
    else
        print_continuation
    fi

    if IFS= read -re user_input; then
        # Clear the prompt line
        echo -en "\r\033[2K"

        # Check for /edit command (only on first line of buffer)
        if [[ -z "$INPUT_BUFFER" ]] && [[ "$user_input" == "/edit" ]]; then
            open_editor
            msg=$(read_editor_result)
            if [[ -n "$msg" ]]; then
                if "$NBS_CHAT" send "$CHAT_FILE" "$HANDLE" "$msg" 2>/dev/null; then
                    format_message "${HANDLE}: ${msg}"
                    MSG_COUNT=$("$NBS_CHAT" read "$CHAT_FILE" 2>/dev/null | grep -c '.' || true)
                else
                    echo -e "  ${DIM}(send failed)${RESET}"
                fi
            else
                echo -e "  ${DIM}(empty — not sent)${RESET}"
            fi
            INPUT_BUFFER=""
            continue
        fi

        # Check for /exit command
        if [[ -z "$INPUT_BUFFER" ]] && [[ "$user_input" == "/exit" ]]; then
            exit 0
        fi

        # Check for /help command
        if [[ -z "$INPUT_BUFFER" ]] && [[ "$user_input" == "/help" ]]; then
            echo ""
            echo -e "${BOLD}Commands:${RESET}"
            echo -e "  ${DIM}/edit${RESET}   Open \$EDITOR to compose a message"
            echo -e "  ${DIM}/help${RESET}   Show this help"
            echo -e "  ${DIM}/exit${RESET}   Leave the chat"
            echo ""
            echo -e "${BOLD}Input:${RESET}"
            echo -e "  ${DIM}Enter${RESET}        Add a line (continuation prompt: ...)"
            echo -e "  ${DIM}Blank line${RESET}   Send the message"
            echo -e "  ${DIM}Ctrl-C${RESET}       Exit"
            echo ""
            continue
        fi

        # Empty line on empty buffer — ignore (no accidental sends)
        if [[ -z "$INPUT_BUFFER" ]] && [[ -z "$user_input" ]]; then
            continue
        fi

        # Empty line with content in buffer — send
        if [[ -n "$INPUT_BUFFER" ]] && [[ -z "$user_input" ]]; then
            if "$NBS_CHAT" send "$CHAT_FILE" "$HANDLE" "$INPUT_BUFFER" 2>/dev/null; then
                format_message "${HANDLE}: ${INPUT_BUFFER}"
                MSG_COUNT=$("$NBS_CHAT" read "$CHAT_FILE" 2>/dev/null | grep -c '.' || true)
            else
                echo -e "  ${DIM}(send failed)${RESET}"
            fi
            INPUT_BUFFER=""
            continue
        fi

        # Non-empty line — append to buffer
        if [[ -z "$INPUT_BUFFER" ]]; then
            INPUT_BUFFER="$user_input"
        else
            INPUT_BUFFER="${INPUT_BUFFER}
${user_input}"
        fi
    else
        # EOF (Ctrl-D)
        # Send any remaining buffer before exiting
        if [[ -n "$INPUT_BUFFER" ]]; then
            "$NBS_CHAT" send "$CHAT_FILE" "$HANDLE" "$INPUT_BUFFER" 2>/dev/null
        fi
        exit 0
    fi
done
