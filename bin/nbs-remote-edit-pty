#!/bin/bash
# nbs-remote-edit-pty: Edit files on remote machines via pty-session
#
# BpfJailer-proof alternative to nbs-remote-edit. Same pull/edit/push
# workflow, but transfers files through an existing pty-session using
# base64 encoding instead of SSH.
#
# Usage:
#   nbs-remote-edit-pty pull <session> <remote-path>   Download file for local editing
#   nbs-remote-edit-pty push <session> <remote-path>   Upload edited file back
#   nbs-remote-edit-pty diff <session> <remote-path>   Show diff between local and remote
#   nbs-remote-edit-pty help                            Show this help
#
# Arguments:
#   <session>      Name of an existing pty-session (e.g. devgpu-p3b)
#   <remote-path>  Absolute path on the remote machine
#
# Environment:
#   NBS_REMOTE_EDIT_DIR   Local staging directory (default: .nbs/remote-edit)
#   NBS_PTY_POLL          Poll interval in seconds for pty-session reads (default: 2)
#   NBS_PTY_TIMEOUT       Timeout for pty-session operations in seconds (default: 30)
#
# How it works:
#   pull: Sends 'base64 <file>' via pty-session, captures output, decodes locally
#   push: Encodes local file as base64, sends 'echo <b64> | base64 -d > <file>'
#   diff: Pulls a fresh copy to a temp file and diffs against the local staging copy
#
# The base64 encoding ensures no character in the file content can corrupt
# the pty-session transport (no quote escaping, no control characters).
#
# Exit codes:
#   0 - Success
#   1 - General error
#   2 - File not found (remote or local)
#   3 - pty-session error (session not found, timeout)
#   4 - Invalid arguments
#   5 - Verification failed (push integrity check)

set -euo pipefail

PTY_SESSION="${HOME}/.nbs/bin/pty-session"
STAGING_DIR="${NBS_REMOTE_EDIT_DIR:-.nbs/remote-edit}"
POLL="${NBS_PTY_POLL:-2}"
TIMEOUT="${NBS_PTY_TIMEOUT:-30}"

# Suppress pty-session tool header (we ARE the higher-level tool)
export NBS_PTY_QUIET=1

# Unique marker to delimit base64 output from shell noise
# Keep markers SHORT to avoid pty-session line-wrapping artifacts
MARKER_COUNTER=0

gen_markers() {
    MARKER_COUNTER=$((MARKER_COUNTER + 1))
    local ts=$(date +%s)
    MARKER_START="B64S${$}x${MARKER_COUNTER}x${ts}"
    MARKER_END="B64E${$}x${MARKER_COUNTER}x${ts}"
}

usage() {
    grep '^#' "$0" | grep -v '!/bin/bash' | cut -c3-
}

local_path() {
    local session="$1"
    local remote_path="$2"
    echo "${STAGING_DIR}/${session}${remote_path}"
}

# Send a command to pty-session and wait for a marker in the output.
# Returns the output between MARKER_START and MARKER_END.
pty_exec() {
    local session="$1"
    local cmd="$2"

    # Generate unique markers for this invocation
    gen_markers

    # Verify session exists
    if ! "$PTY_SESSION" read "$session" --last=1 >/dev/null 2>&1; then
        echo "Error: pty-session '$session' not found" >&2
        return 3
    fi

    # Wrap command with markers so we can extract just its output.
    # Send markers as separate echo commands to ensure they appear
    # on their own lines even with pty line-wrapping.
    "$PTY_SESSION" send "$session" "echo ${MARKER_START}"
    sleep 0.3
    "$PTY_SESSION" send "$session" "${cmd}"
    sleep 0.3
    "$PTY_SESSION" send "$session" "echo ${MARKER_END}"

    # Poll for the end marker
    local elapsed=0
    local output=""
    while (( elapsed < TIMEOUT )); do
        sleep "$POLL"
        elapsed=$((elapsed + POLL))

        output=$("$PTY_SESSION" read "$session" --last=500 2>/dev/null) || true
        if echo "$output" | grep -q "^${MARKER_END}$\|^${MARKER_END}[[:space:]]*$"; then
            # Extract content between markers, filtering out:
            # - Lines containing the markers themselves
            # - Prompt lines (lines starting with $> or containing echo MARKER)
            echo "$output" | sed -n "/${MARKER_START}/,/${MARKER_END}/p" \
                | grep -v "${MARKER_START}" \
                | grep -v "${MARKER_END}" \
                | grep -v '^\$>' \
                | grep -v '^[[:space:]]*$'
            return 0
        fi
    done

    echo "Error: Timed out waiting for command to complete (${TIMEOUT}s)" >&2
    return 3
}

cmd_pull() {
    local session="${1:-}"
    local remote_path="${2:-}"

    if [[ -z "$session" ]] || [[ -z "$remote_path" ]]; then
        echo "Error: pull requires <session> and <remote-path>" >&2
        echo "Usage: nbs-remote-edit-pty pull <session> <remote-path>" >&2
        return 4
    fi

    local lpath
    lpath=$(local_path "$session" "$remote_path")
    local ldir
    ldir=$(dirname "$lpath")
    mkdir -p "$ldir"

    # Check if remote file exists
    local exists_check
    exists_check=$(pty_exec "$session" "test -f $(printf '%q' "$remote_path") && echo EXISTS || echo NOTFOUND") || return $?
    if echo "$exists_check" | grep -q "NOTFOUND"; then
        echo "Error: Remote file not found: ${remote_path}" >&2
        return 2
    fi

    # Download via base64 encoding
    local b64_output
    b64_output=$(pty_exec "$session" "base64 $(printf '%q' "$remote_path")") || return $?

    if [[ -z "$b64_output" ]]; then
        echo "Error: Got empty base64 output for ${remote_path}" >&2
        return 1
    fi

    # Decode and save locally
    # Strip any whitespace/newlines that pty-session may have added
    # Also strip any prompt characters ($>) that may leak into output
    if ! echo "$b64_output" | tr -d '[:space:]' | base64 -d > "$lpath" 2>/dev/null; then
        rm -f "$lpath"
        echo "Error: base64 decode failed — output may be corrupted" >&2
        return 1
    fi

    # Verify we got content
    if [[ ! -s "$lpath" ]]; then
        echo "Warning: Downloaded file is empty: ${remote_path}" >&2
    fi

    # Get remote checksum for later verification
    local remote_md5
    remote_md5=$(pty_exec "$session" "md5sum $(printf '%q' "$remote_path") | cut -d' ' -f1") || true
    local local_md5
    local_md5=$(md5sum "$lpath" 2>/dev/null | cut -d' ' -f1) || true

    if [[ -n "$remote_md5" ]] && [[ -n "$local_md5" ]]; then
        # Clean up any whitespace in checksums
        remote_md5=$(echo "$remote_md5" | tr -d '[:space:]')
        local_md5=$(echo "$local_md5" | tr -d '[:space:]')
        if [[ "$remote_md5" != "$local_md5" ]]; then
            echo "Warning: Checksum mismatch after pull (remote=$remote_md5, local=$local_md5)" >&2
            echo "The file may be corrupted — consider retrying" >&2
        fi
    fi

    echo "$lpath"
}

cmd_push() {
    local session="${1:-}"
    local remote_path="${2:-}"

    if [[ -z "$session" ]] || [[ -z "$remote_path" ]]; then
        echo "Error: push requires <session> and <remote-path>" >&2
        echo "Usage: nbs-remote-edit-pty push <session> <remote-path>" >&2
        return 4
    fi

    local lpath
    lpath=$(local_path "$session" "$remote_path")

    if [[ ! -f "$lpath" ]]; then
        echo "Error: Local file not found: $lpath" >&2
        echo "Did you run 'nbs-remote-edit-pty pull' first?" >&2
        return 2
    fi

    # Get local checksum before push
    local local_md5
    local_md5=$(md5sum "$lpath" | cut -d' ' -f1)

    # Encode file as base64
    local b64_content
    b64_content=$(base64 -w0 "$lpath")

    # For large files, split into chunks to avoid pty-session line length issues.
    # tmux has a ~500-character input limit per send-keys call.
    local b64_len=${#b64_content}

    if (( b64_len > 400 )); then
        # Write base64 to a temp file on the remote, then decode
        local remote_tmp="/tmp/nbs_edit_$$_$(date +%s)"

        # Clear the temp file
        "$PTY_SESSION" send "$session" "> ${remote_tmp}"
        sleep 1

        # Send in chunks of 400 chars
        local offset=0
        local chunk_size=400
        while (( offset < b64_len )); do
            local chunk="${b64_content:$offset:$chunk_size}"
            "$PTY_SESSION" send "$session" "echo -n '${chunk}' >> ${remote_tmp}"
            sleep 0.5
            offset=$((offset + chunk_size))
        done

        # Wait for all chunks to be written
        sleep 2

        # Decode the temp file to the target
        local push_token="PDONE${$}x$(date +%s)"
        local decode_result
        decode_result=$(pty_exec "$session" "base64 -d ${remote_tmp} > $(printf '%q' "$remote_path") && echo ${push_token} || echo PFAIL${$}") || {
            echo "Error: Failed to decode on remote" >&2
            "$PTY_SESSION" send "$session" "rm -f ${remote_tmp}"
            return 3
        }

        # Clean up temp file
        "$PTY_SESSION" send "$session" "rm -f ${remote_tmp}"

        if ! echo "$decode_result" | grep -q "${push_token}"; then
            echo "Error: base64 decode failed on remote" >&2
            return 1
        fi
    else
        # Small file: single command
        local push_token="PDONE${$}x$(date +%s)"
        local result
        result=$(pty_exec "$session" "echo '${b64_content}' | base64 -d > $(printf '%q' "$remote_path") && echo ${push_token}") || return $?

        if ! echo "$result" | grep -q "${push_token}"; then
            echo "Error: Push failed on remote" >&2
            return 1
        fi
    fi

    # Verify: compare checksums
    local remote_md5
    remote_md5=$(pty_exec "$session" "md5sum $(printf '%q' "$remote_path") | cut -d' ' -f1") || true
    remote_md5=$(echo "$remote_md5" | tr -d '[:space:]')

    if [[ -n "$remote_md5" ]] && [[ "$remote_md5" != "$local_md5" ]]; then
        echo "VERIFICATION FAILED: checksum mismatch after push" >&2
        echo "  local:  $local_md5" >&2
        echo "  remote: $remote_md5" >&2
        echo "The remote file may be corrupted. Revert with:" >&2
        echo "  pty-session send $session 'git checkout -- $(printf '%q' "$remote_path")'" >&2
        return 5
    fi

    echo "Pushed: ${remote_path} -> ${session} (verified: md5=$local_md5)"
}

cmd_diff() {
    local session="${1:-}"
    local remote_path="${2:-}"

    if [[ -z "$session" ]] || [[ -z "$remote_path" ]]; then
        echo "Error: diff requires <session> and <remote-path>" >&2
        return 4
    fi

    local lpath
    lpath=$(local_path "$session" "$remote_path")

    if [[ ! -f "$lpath" ]]; then
        echo "Error: Local file not found: $lpath" >&2
        return 2
    fi

    # Pull a fresh copy for comparison
    local tmp
    tmp=$(mktemp)
    trap "rm -f '$tmp'" RETURN

    # Download via base64
    local b64_output
    b64_output=$(pty_exec "$session" "base64 $(printf '%q' "$remote_path")") || {
        rm -f "$tmp"
        return $?
    }

    echo "$b64_output" | tr -d '[:space:]' | base64 -d > "$tmp" 2>/dev/null || {
        rm -f "$tmp"
        echo "Error: base64 decode failed during diff" >&2
        return 1
    }

    diff -u "$tmp" "$lpath" --label "remote:${remote_path}" --label "local:${lpath}" || true
}

# Main dispatch
case "${1:-}" in
    pull)
        shift
        cmd_pull "$@"
        ;;
    push)
        shift
        cmd_push "$@"
        ;;
    diff)
        shift
        cmd_diff "$@"
        ;;
    help|--help|-h|"")
        usage
        ;;
    *)
        echo "Unknown command: $1" >&2
        echo "Run 'nbs-remote-edit-pty help' for usage" >&2
        exit 4
        ;;
esac
