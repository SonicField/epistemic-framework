#!/bin/bash
# nbs-claude: Launch Claude Code with automatic chat/worker polling
#
# Runs claude with a background sidecar that monitors for idle state
# and injects /nbs-poll when claude is waiting for user input.
#
# Works in two modes:
#   - Inside tmux: runs claude in the current pane, sidecar monitors it
#   - Outside tmux: creates a pty-session, attaches to it
#
# Usage:
#   nbs-claude [claude-args...]
#
# Examples:
#   nbs-claude                    # Start interactive claude
#   nbs-claude --resume abc123   # Resume session with polling
#
# Environment:
#   NBS_POLL_INTERVAL  Seconds of idle before injecting poll (default: 30)
#   NBS_POLL_DISABLE   Set to 1 to disable polling (just wraps claude)
#
# Exit codes:
#   0 - Clean exit
#   1 - General error
#   4 - Invalid arguments

set -uo pipefail

# --- Configuration ---

POLL_INTERVAL="${NBS_POLL_INTERVAL:-30}"
POLL_DISABLE="${NBS_POLL_DISABLE:-0}"

# Resolve tools
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PTY_SESSION="${SCRIPT_DIR}/pty-session"

if [[ ! -x "$PTY_SESSION" ]]; then
    PTY_SESSION="${HOME}/.nbs/bin/pty-session"
fi

if [[ ! -x "$PTY_SESSION" ]]; then
    echo "Error: pty-session not found" >&2
    exit 1
fi

# --- Cleanup ---

SIDECAR_PID=""
SESSION_NAME=""
MODE=""

cleanup() {
    # Kill sidecar if running
    if [[ -n "$SIDECAR_PID" ]] && kill -0 "$SIDECAR_PID" 2>/dev/null; then
        kill "$SIDECAR_PID" 2>/dev/null
        wait "$SIDECAR_PID" 2>/dev/null
    fi

    # Kill pty-session if we created one
    if [[ "$MODE" == "pty" && -n "$SESSION_NAME" ]]; then
        "$PTY_SESSION" kill "$SESSION_NAME" 2>/dev/null
    fi

    exit 0
}
trap cleanup INT TERM EXIT

# --- Plan mode detection ---
# Claude Code's plan mode displays an interactive menu that blocks execution.
# The sidecar detects this prompt and auto-selects option 2 ("Yes, and bypass
# permissions") so unattended workers are not blocked indefinitely.

detect_plan_mode() {
    local content="$1"
    echo "$content" | grep -qF 'Would you like to proceed?'
}

# --- Dynamic resource registration ---
# The AI declares what resources it needs by writing to .nbs/control-inbox.
# The sidecar reads new lines (forward-only, never truncates) and maintains
# a resource registry at .nbs/control-registry.
#
# Convention: / = human-to-AI, \ = AI-to-wrapper
# The AI outputs \nbs-register-chat etc. which writes to the control inbox.
# See feature-requests/dynamic-registration.md for full design.

CONTROL_INBOX=".nbs/control-inbox"
CONTROL_REGISTRY=".nbs/control-registry"
CONTROL_INBOX_LINE=0

# seed_registry — populate registry from existing .nbs/ resources on startup.
# Idempotent: skips resources already registered.
seed_registry() {
    # Create registry file if it does not exist
    mkdir -p "$(dirname "$CONTROL_REGISTRY")"
    touch "$CONTROL_REGISTRY"

    # Register existing chat files
    for chat in .nbs/chat/*.chat; do
        [[ -f "$chat" ]] || continue
        if ! grep -qF "chat:${chat}" "$CONTROL_REGISTRY" 2>/dev/null; then
            echo "chat:${chat}" >> "$CONTROL_REGISTRY"
        fi
    done

    # Register bus directory if it exists
    if [[ -d .nbs/events ]]; then
        if ! grep -qF "bus:.nbs/events" "$CONTROL_REGISTRY" 2>/dev/null; then
            echo "bus:.nbs/events" >> "$CONTROL_REGISTRY"
        fi
    fi
}

# process_control_command — handle a single control command line.
# Precondition: line is non-empty and has been stripped of whitespace.
# Postcondition: registry is updated if command is valid; invalid lines are ignored.
process_control_command() {
    local line="$1"
    local verb path

    verb=$(echo "$line" | awk '{print $1}')
    path=$(echo "$line" | awk '{print $2}')

    # Require both verb and path
    [[ -z "$verb" || -z "$path" ]] && return

    case "$verb" in
        register-chat)
            if ! grep -qF "chat:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                echo "chat:${path}" >> "$CONTROL_REGISTRY"
                echo "[nbs-claude] Registered chat: $path" >&2
            fi
            ;;
        unregister-chat)
            if grep -qF "chat:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                grep -vF "chat:${path}" "$CONTROL_REGISTRY" > "${CONTROL_REGISTRY}.tmp"
                mv "${CONTROL_REGISTRY}.tmp" "$CONTROL_REGISTRY"
                echo "[nbs-claude] Unregistered chat: $path" >&2
            fi
            ;;
        register-bus)
            if ! grep -qF "bus:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                echo "bus:${path}" >> "$CONTROL_REGISTRY"
                echo "[nbs-claude] Registered bus: $path" >&2
            fi
            ;;
        unregister-bus)
            if grep -qF "bus:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                grep -vF "bus:${path}" "$CONTROL_REGISTRY" > "${CONTROL_REGISTRY}.tmp"
                mv "${CONTROL_REGISTRY}.tmp" "$CONTROL_REGISTRY"
                echo "[nbs-claude] Unregistered bus: $path" >&2
            fi
            ;;
        register-hub)
            if ! grep -qF "hub:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                echo "hub:${path}" >> "$CONTROL_REGISTRY"
                echo "[nbs-claude] Registered hub: $path" >&2
            fi
            ;;
        unregister-hub)
            if grep -qF "hub:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                grep -vF "hub:${path}" "$CONTROL_REGISTRY" > "${CONTROL_REGISTRY}.tmp"
                mv "${CONTROL_REGISTRY}.tmp" "$CONTROL_REGISTRY"
                echo "[nbs-claude] Unregistered hub: $path" >&2
            fi
            ;;
        set-poll-interval)
            # Validate: must be a positive integer
            if [[ "$path" =~ ^[0-9]+$ ]] && [[ "$path" -gt 0 ]]; then
                POLL_INTERVAL="$path"
                echo "[nbs-claude] Poll interval set to ${path}s" >&2
            fi
            ;;
        *)
            # Unknown command — silently ignore
            ;;
    esac
}

# check_control_inbox — process new lines from the control inbox.
# Forward-only: tracks line offset, never re-processes old lines, never truncates.
# Called every sidecar iteration (1 second).
check_control_inbox() {
    [[ -f "$CONTROL_INBOX" ]] || return

    local total_lines
    total_lines=$(wc -l < "$CONTROL_INBOX" 2>/dev/null) || return
    total_lines=$((total_lines + 0))  # ensure numeric

    if [[ $total_lines -gt $CONTROL_INBOX_LINE ]]; then
        local new_lines
        new_lines=$(tail -n +"$((CONTROL_INBOX_LINE + 1))" "$CONTROL_INBOX")

        while IFS= read -r line; do
            # Strip leading/trailing whitespace
            line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            [[ -z "$line" ]] && continue
            # Skip comment lines
            [[ "$line" == \#* ]] && continue
            process_control_command "$line"
        done <<< "$new_lines"

        CONTROL_INBOX_LINE=$total_lines
    fi
}

# --- Idle detection sidecar (tmux mode) ---
# Monitors the current tmux pane for idle and injects /nbs-poll.
# Also checks the control inbox for dynamic resource registration.

poll_sidecar_tmux() {
    local interval="$1"
    local pane_id="$2"

    local idle_seconds=0
    local last_content_hash=""

    # Seed registry with existing resources
    seed_registry

    while true; do
        sleep 1

        # Check control inbox for new registration commands
        check_control_inbox

        # Check pane still exists
        if ! tmux list-panes -t "$pane_id" &>/dev/null; then
            break
        fi

        # Capture current pane content
        local content
        content=$(tmux capture-pane -t "$pane_id" -p -S -5 2>/dev/null) || continue

        # Hash the content to detect changes
        local current_hash
        current_hash=$(echo "$content" | md5sum | cut -d' ' -f1)

        if [[ "$current_hash" != "$last_content_hash" ]]; then
            idle_seconds=0
            last_content_hash="$current_hash"

            # Check for plan mode immediately on content change
            # Plan mode blocks the worker — resolve it without waiting for idle
            if detect_plan_mode "$content"; then
                sleep 1
                tmux send-keys -t "$pane_id" '2'
                sleep 0.5
                tmux send-keys -t "$pane_id" Enter
                idle_seconds=0
                last_content_hash=""
                sleep 5
            fi
            continue
        fi

        # Also check for plan mode when content is stable (already idle)
        if detect_plan_mode "$content"; then
            tmux send-keys -t "$pane_id" '2'
            sleep 0.5
            tmux send-keys -t "$pane_id" Enter
            idle_seconds=0
            last_content_hash=""
            sleep 5
            continue
        fi

        idle_seconds=$((idle_seconds + 1))

        if [[ $idle_seconds -ge $interval ]]; then
            # Check if claude appears to be at a prompt
            if echo "$content" | tail -3 | grep -qE '❯|>\s*$'; then
                # Inject /nbs-poll followed by Enter
                # Send text first, small delay, then Enter separately
                # Claude Code may not process pasted text + Enter atomically
                tmux send-keys -t "$pane_id" -l '/nbs-poll'
                sleep 0.3
                tmux send-keys -t "$pane_id" Enter

                idle_seconds=0
                last_content_hash=""

                # Wait for poll to complete
                sleep 10
            else
                idle_seconds=0
            fi
        fi
    done
}

# --- Idle detection sidecar (pty-session mode) ---

poll_sidecar_pty() {
    local pty="$1"
    local session="$2"
    local interval="$3"

    local idle_seconds=0
    local last_content_hash=""

    # Seed registry with existing resources
    seed_registry

    while true; do
        sleep 1

        # Check control inbox for new registration commands
        check_control_inbox

        if ! "$pty" list 2>/dev/null | grep -q "$session"; then
            break
        fi

        local content
        content=$("$pty" read "$session" --scrollback=5 2>/dev/null) || continue

        local current_hash
        current_hash=$(echo "$content" | md5sum | cut -d' ' -f1)

        if [[ "$current_hash" != "$last_content_hash" ]]; then
            idle_seconds=0
            last_content_hash="$current_hash"

            # Check for plan mode immediately on content change
            if detect_plan_mode "$content"; then
                sleep 1
                "$pty" send "$session" --no-enter '2'
                sleep 0.5
                "$pty" send "$session" ''
                idle_seconds=0
                last_content_hash=""
                sleep 5
            fi
            continue
        fi

        # Check for plan mode when content is stable
        if detect_plan_mode "$content"; then
            "$pty" send "$session" --no-enter '2'
            sleep 0.5
            "$pty" send "$session" ''
            idle_seconds=0
            last_content_hash=""
            sleep 5
            continue
        fi

        idle_seconds=$((idle_seconds + 1))

        if [[ $idle_seconds -ge $interval ]]; then
            if echo "$content" | tail -3 | grep -qE '❯|>\s*$'; then
                "$pty" send "$session" '/nbs-poll'
                sleep 0.5
                "$pty" send "$session" ''

                idle_seconds=0
                last_content_hash=""
                sleep 10
            else
                idle_seconds=0
            fi
        fi
    done
}

# --- Main ---

# Build claude command with args
CLAUDE_ARGS=("claude")
for arg in "$@"; do
    CLAUDE_ARGS+=("$arg")
done

echo "Starting Claude Code with NBS polling..."
echo "  Poll interval: ${POLL_INTERVAL}s idle"
if [[ "$POLL_DISABLE" == "1" ]]; then
    echo "  Polling: DISABLED"
fi

if [[ -n "${TMUX:-}" ]]; then
    # --- Already inside tmux ---
    MODE="tmux"

    # Get current pane ID before launching claude
    PANE_ID=$(tmux display-message -p '#{pane_id}')
    echo "  Mode: tmux (pane $PANE_ID)"
    echo ""

    # Start sidecar monitoring this pane
    if [[ "$POLL_DISABLE" != "1" ]]; then
        poll_sidecar_tmux "$POLL_INTERVAL" "$PANE_ID" &
        SIDECAR_PID=$!
    fi

    # Run claude in foreground — replaces this process's foreground
    # but the sidecar is already running in background
    "${CLAUDE_ARGS[@]}"

    # Claude exited — cleanup runs via trap
else
    # --- Not inside tmux ---
    MODE="pty"
    SESSION_NAME="nbs-claude-$$"

    echo "  Mode: pty-session ($SESSION_NAME)"
    echo ""

    # Build command string for pty-session
    CLAUDE_CMD="claude"
    if [[ $# -gt 0 ]]; then
        CLAUDE_CMD_ARGS=""
        for arg in "$@"; do
            if [[ -z "$CLAUDE_CMD_ARGS" ]]; then
                CLAUDE_CMD_ARGS="$(printf '%q' "$arg")"
            else
                CLAUDE_CMD_ARGS="$CLAUDE_CMD_ARGS $(printf '%q' "$arg")"
            fi
        done
        CLAUDE_CMD="claude $CLAUDE_CMD_ARGS"
    fi

    # Create pty-session running claude
    "$PTY_SESSION" create "$SESSION_NAME" "$CLAUDE_CMD"

    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to create pty-session" >&2
        exit 1
    fi

    # Start sidecar if polling enabled
    if [[ "$POLL_DISABLE" != "1" ]]; then
        poll_sidecar_pty "$PTY_SESSION" "$SESSION_NAME" "$POLL_INTERVAL" &
        SIDECAR_PID=$!
    fi

    # Attach to the session
    tmux attach-session -t "pty_${SESSION_NAME}"
fi

# When user exits, cleanup runs via trap
