#!/bin/bash
# nbs-claude: Launch Claude Code with bus-aware event-driven notification
#
# Runs claude with a background sidecar that:
#   1. Checks the event bus every few seconds for pending events
#   2. Checks chat cursors for unread messages
#   3. Injects /nbs-notify only when there is something to process
#   4. Injects /nbs-poll as a safety net after extended idle (5 min)
#   5. Auto-selects plan mode prompts for unattended workers
#
# Works in two modes:
#   - Inside tmux: runs claude in the current pane, sidecar monitors it
#   - Outside tmux: creates a pty-session, attaches to it
#
# Usage:
#   nbs-claude [--root=PATH] [claude-args...]
#
# Examples:
#   nbs-claude                    # Start interactive claude
#   nbs-claude --resume abc123   # Resume session with polling
#   nbs-claude --root=/path/to/project  # Use .nbs/ from another directory
#
# Environment:
#   NBS_POLL_INTERVAL       Safety net poll interval in seconds (default: 300)
#   NBS_POLL_DISABLE        Set to 1 to disable all polling (just wraps claude)
#   NBS_BUS_CHECK_INTERVAL  Bus/chat check interval in seconds (default: 3)
#   NBS_NOTIFY_COOLDOWN     Min seconds between /nbs-notify injections (default: 15)
#   NBS_HANDLE              Agent handle for cursor peeking (default: claude)
#   NBS_ROOT                Project root containing .nbs/ (default: current directory)
#
# Exit codes:
#   0 - Clean exit
#   1 - General error
#   4 - Invalid arguments

set -uo pipefail

# --- Configuration ---

POLL_INTERVAL="${NBS_POLL_INTERVAL:-300}"
POLL_DISABLE="${NBS_POLL_DISABLE:-0}"
BUS_CHECK_INTERVAL="${NBS_BUS_CHECK_INTERVAL:-3}"
NOTIFY_COOLDOWN="${NBS_NOTIFY_COOLDOWN:-15}"
SIDECAR_HANDLE="${NBS_HANDLE:-claude}"
NBS_ROOT="${NBS_ROOT:-.}"

# Resolve tools
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PTY_SESSION="${SCRIPT_DIR}/pty-session"

if [[ ! -x "$PTY_SESSION" ]]; then
    PTY_SESSION="${HOME}/.nbs/bin/pty-session"
fi

if [[ ! -x "$PTY_SESSION" ]]; then
    echo "Error: pty-session not found" >&2
    exit 1
fi

# --- Cleanup ---

SIDECAR_PID=""
SESSION_NAME=""
MODE=""

cleanup() {
    # Kill sidecar if running
    if [[ -n "$SIDECAR_PID" ]] && kill -0 "$SIDECAR_PID" 2>/dev/null; then
        kill "$SIDECAR_PID" 2>/dev/null
        wait "$SIDECAR_PID" 2>/dev/null
    fi

    # Kill pty-session if we created one
    if [[ "$MODE" == "pty" && -n "$SESSION_NAME" ]]; then
        "$PTY_SESSION" kill "$SESSION_NAME" 2>/dev/null
    fi

    exit 0
}
trap cleanup INT TERM EXIT

# --- Plan mode detection ---
# Claude Code's plan mode displays an interactive menu that blocks execution.
# The sidecar detects this prompt and auto-selects option 2 ("Yes, and bypass
# permissions") so unattended workers are not blocked indefinitely.

detect_plan_mode() {
    local content="$1"
    echo "$content" | grep -qF 'Would you like to proceed?'
}

# --- Dynamic resource registration ---
# The AI declares what resources it needs by writing to .nbs/control-inbox-<handle>.
# The sidecar reads new lines (forward-only, never truncates) and maintains
# a resource registry at .nbs/control-registry-<handle>.
#
# Convention: / = human-to-AI, \ = AI-to-wrapper
# The AI outputs \nbs-register-chat etc. which writes to the control inbox.
# See feature-requests/dynamic-registration.md for full design.

CONTROL_INBOX="${NBS_ROOT}/.nbs/control-inbox-${SIDECAR_HANDLE}"
CONTROL_REGISTRY="${NBS_ROOT}/.nbs/control-registry-${SIDECAR_HANDLE}"
CONTROL_INBOX_LINE=0

# seed_registry — populate registry from existing .nbs/ resources on startup.
# Idempotent: skips resources already registered.
seed_registry() {
    # Create registry file if it does not exist
    mkdir -p "$(dirname "$CONTROL_REGISTRY")"
    touch "$CONTROL_REGISTRY"

    # Register existing chat files
    for chat in "${NBS_ROOT}"/.nbs/chat/*.chat; do
        [[ -f "$chat" ]] || continue
        if ! grep -qF "chat:${chat}" "$CONTROL_REGISTRY" 2>/dev/null; then
            echo "chat:${chat}" >> "$CONTROL_REGISTRY"
        fi
    done

    # Register bus directory if it exists
    if [[ -d "${NBS_ROOT}/.nbs/events" ]]; then
        if ! grep -qF "bus:${NBS_ROOT}/.nbs/events" "$CONTROL_REGISTRY" 2>/dev/null; then
            echo "bus:${NBS_ROOT}/.nbs/events" >> "$CONTROL_REGISTRY"
        fi
    fi
}

# process_control_command — handle a single control command line.
# Precondition: line is non-empty and has been stripped of whitespace.
# Postcondition: registry is updated if command is valid; invalid lines are ignored.
process_control_command() {
    local line="$1"
    local verb path

    verb=$(echo "$line" | awk '{print $1}')
    path=$(echo "$line" | awk '{print $2}')

    # Require both verb and path
    [[ -z "$verb" || -z "$path" ]] && return

    case "$verb" in
        register-chat)
            if ! grep -qF "chat:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                echo "chat:${path}" >> "$CONTROL_REGISTRY"
                echo "[nbs-claude] Registered chat: $path" >&2
            fi
            ;;
        unregister-chat)
            if grep -qF "chat:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                grep -vF "chat:${path}" "$CONTROL_REGISTRY" > "${CONTROL_REGISTRY}.tmp"
                mv "${CONTROL_REGISTRY}.tmp" "$CONTROL_REGISTRY"
                echo "[nbs-claude] Unregistered chat: $path" >&2
            fi
            ;;
        register-bus)
            if ! grep -qF "bus:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                echo "bus:${path}" >> "$CONTROL_REGISTRY"
                echo "[nbs-claude] Registered bus: $path" >&2
            fi
            ;;
        unregister-bus)
            if grep -qF "bus:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                grep -vF "bus:${path}" "$CONTROL_REGISTRY" > "${CONTROL_REGISTRY}.tmp"
                mv "${CONTROL_REGISTRY}.tmp" "$CONTROL_REGISTRY"
                echo "[nbs-claude] Unregistered bus: $path" >&2
            fi
            ;;
        register-hub)
            if ! grep -qF "hub:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                echo "hub:${path}" >> "$CONTROL_REGISTRY"
                echo "[nbs-claude] Registered hub: $path" >&2
            fi
            ;;
        unregister-hub)
            if grep -qF "hub:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                grep -vF "hub:${path}" "$CONTROL_REGISTRY" > "${CONTROL_REGISTRY}.tmp"
                mv "${CONTROL_REGISTRY}.tmp" "$CONTROL_REGISTRY"
                echo "[nbs-claude] Unregistered hub: $path" >&2
            fi
            ;;
        set-poll-interval)
            # Validate: must be a positive integer
            if [[ "$path" =~ ^[0-9]+$ ]] && [[ "$path" -gt 0 ]]; then
                POLL_INTERVAL="$path"
                echo "[nbs-claude] Poll interval set to ${path}s" >&2
            fi
            ;;
        *)
            # Unknown command — silently ignore
            ;;
    esac
}

# check_control_inbox — process new lines from the control inbox.
# Forward-only: tracks line offset, never re-processes old lines, never truncates.
# Called every sidecar iteration (1 second).
check_control_inbox() {
    [[ -f "$CONTROL_INBOX" ]] || return

    local total_lines
    total_lines=$(wc -l < "$CONTROL_INBOX" 2>/dev/null) || return
    total_lines=$((total_lines + 0))  # ensure numeric

    if [[ $total_lines -gt $CONTROL_INBOX_LINE ]]; then
        local new_lines
        new_lines=$(tail -n +"$((CONTROL_INBOX_LINE + 1))" "$CONTROL_INBOX")

        while IFS= read -r line; do
            # Strip leading/trailing whitespace
            line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            [[ -z "$line" ]] && continue
            # Skip comment lines
            [[ "$line" == \#* ]] && continue
            process_control_command "$line"
        done <<< "$new_lines"

        CONTROL_INBOX_LINE=$total_lines
    fi
}

# --- Bus-aware event checking ---
# The sidecar checks the bus and chat cursors directly, injecting /nbs-notify
# only when there is something to process. This replaces blind /nbs-poll
# injection which wastes context on empty checks.

# Globals set by check functions
BUS_EVENT_COUNT=0
BUS_MAX_PRIORITY="none"
BUS_EVENT_SUMMARY=""
CHAT_UNREAD_COUNT=0
CHAT_UNREAD_SUMMARY=""
NOTIFY_MESSAGE=""
LAST_NOTIFY_TIME=0

# check_bus_events — peek at the event bus without consuming anything.
# Reads the control registry for bus: entries, runs nbs-bus check on each.
# Sets BUS_EVENT_COUNT, BUS_MAX_PRIORITY, BUS_EVENT_SUMMARY.
# Returns: 0 = events found, 1 = empty, 2 = no bus registered.
check_bus_events() {
    BUS_EVENT_COUNT=0
    BUS_MAX_PRIORITY="none"
    BUS_EVENT_SUMMARY=""

    [[ -f "$CONTROL_REGISTRY" ]] || return 2

    local has_bus=0
    local output

    while IFS= read -r line; do
        case "$line" in
            bus:*)
                local bus_dir="${line#bus:}"
                if [[ -d "$bus_dir" ]]; then
                    has_bus=1
                    output=$(nbs-bus check "$bus_dir" 2>/dev/null) || continue
                    if [[ -n "$output" ]]; then
                        BUS_EVENT_COUNT=$(echo "$output" | wc -l)
                        BUS_EVENT_COUNT=$((BUS_EVENT_COUNT + 0))
                        # Extract highest priority (first line, first bracket group)
                        BUS_MAX_PRIORITY=$(echo "$output" | head -1 | sed 's/^\[\([a-z]*\)\].*/\1/')
                        BUS_EVENT_SUMMARY="${BUS_EVENT_COUNT} event(s) in ${bus_dir}"
                    fi
                fi
                ;;
        esac
    done < "$CONTROL_REGISTRY"

    [[ $has_bus -eq 0 ]] && return 2
    [[ $BUS_EVENT_COUNT -eq 0 ]] && return 1
    return 0
}

# check_chat_unread — peek at chat cursors without advancing them.
# Reads cursor files directly (no lock, no modification) and compares
# against total message count. Format: handle=index in <chat>.cursors.
# See src/nbs-chat/chat_file.c for cursor file format.
# Sets CHAT_UNREAD_COUNT, CHAT_UNREAD_SUMMARY.
# Returns: 0 = unread found, 1 = caught up, 2 = no chats registered.
check_chat_unread() {
    CHAT_UNREAD_COUNT=0
    CHAT_UNREAD_SUMMARY=""

    [[ -f "$CONTROL_REGISTRY" ]] || return 2

    local has_chat=0
    local unread_chats=""

    while IFS= read -r line; do
        case "$line" in
            chat:*)
                local chat_path="${line#chat:}"
                [[ -f "$chat_path" ]] || continue
                has_chat=1

                # Count total messages: non-empty lines after --- delimiter
                local total
                total=$(awk '/^---$/{found=1; next} found && NF{count++} END{print count+0}' "$chat_path" 2>/dev/null)
                total=$((total + 0))

                # Read cursor for our handle (no lock, no advancement)
                local cursor=0
                if [[ -f "${chat_path}.cursors" ]]; then
                    cursor=$(awk -F= -v h="$SIDECAR_HANDLE" '$1==h{print $2}' "${chat_path}.cursors" 2>/dev/null)
                    cursor=$((${cursor:-0} + 0))
                fi

                # Unread if total messages > cursor position + 1
                # (cursor is 0-indexed: cursor=0 means message 0 has been read)
                if (( total > cursor + 1 )); then
                    local chat_name
                    chat_name=$(basename "$chat_path")
                    local n_unread=$((total - cursor - 1))
                    CHAT_UNREAD_COUNT=$((CHAT_UNREAD_COUNT + n_unread))
                    if [[ -n "$unread_chats" ]]; then
                        unread_chats="${unread_chats}, ${chat_name}"
                    else
                        unread_chats="$chat_name"
                    fi
                fi
                ;;
        esac
    done < "$CONTROL_REGISTRY"

    if [[ $CHAT_UNREAD_COUNT -gt 0 ]]; then
        CHAT_UNREAD_SUMMARY="${CHAT_UNREAD_COUNT} unread in ${unread_chats}"
    fi

    [[ $has_chat -eq 0 ]] && return 2
    [[ $CHAT_UNREAD_COUNT -eq 0 ]] && return 1
    return 0
}

# should_inject_notify — decide whether to inject /nbs-notify.
# Combines bus and chat checks, applies cooldown logic.
# Critical priority bypasses cooldown.
# Sets NOTIFY_MESSAGE with summary text (capped at 200 chars).
# Returns: 0 = should inject, 1 = should not.
should_inject_notify() {
    NOTIFY_MESSAGE=""

    check_bus_events
    local bus_rc=$?

    check_chat_unread
    local chat_rc=$?

    # Nothing pending
    if [[ $bus_rc -ne 0 && $chat_rc -ne 0 ]]; then
        return 1
    fi

    # Apply cooldown (critical bypasses)
    local now
    now=$(date +%s)
    local elapsed=$((now - LAST_NOTIFY_TIME))

    if [[ "$BUS_MAX_PRIORITY" != "critical" && $elapsed -lt $NOTIFY_COOLDOWN ]]; then
        return 1
    fi

    # Build summary message
    local parts=""
    if [[ -n "$BUS_EVENT_SUMMARY" ]]; then
        parts="$BUS_EVENT_SUMMARY"
    fi
    if [[ -n "$CHAT_UNREAD_SUMMARY" ]]; then
        if [[ -n "$parts" ]]; then
            parts="${parts}. ${CHAT_UNREAD_SUMMARY}"
        else
            parts="$CHAT_UNREAD_SUMMARY"
        fi
    fi

    # Cap at 200 chars for tmux safety
    if [[ ${#parts} -gt 200 ]]; then
        parts="${parts:0:197}..."
    fi

    NOTIFY_MESSAGE="$parts"
    LAST_NOTIFY_TIME=$now
    return 0
}

# --- Prompt detection ---

is_prompt_visible() {
    local content="$1"
    echo "$content" | tail -3 | grep -qF '❯'
}

# --- Idle detection sidecar (tmux mode) ---
# Monitors the current tmux pane. Checks bus/chat every BUS_CHECK_INTERVAL
# seconds and injects /nbs-notify when events or messages are pending.
# Falls back to /nbs-poll as a safety net after POLL_INTERVAL seconds.

poll_sidecar_tmux() {
    local pane_id="$1"

    local idle_seconds=0
    local bus_check_counter=0
    local last_content_hash=""

    # Seed registry with existing resources
    seed_registry

    # Inject initial handle and chat skill prompt
    # Wait for Claude's prompt to appear, then tell it its handle
    local init_wait=0
    while [[ $init_wait -lt 60 ]]; do
        sleep 2
        local init_content
        init_content=$(tmux capture-pane -t "$pane_id" -p -S -5 2>/dev/null) || true
        if echo "$init_content" | tail -3 | grep -qE '❯|>\s*$'; then
            tmux send-keys -t "$pane_id" -l "Your NBS handle is '${SIDECAR_HANDLE}'. Load /nbs-teams-chat. Use this handle for all nbs-chat send commands."
            sleep 0.3
            tmux send-keys -t "$pane_id" Enter
            sleep 5
            last_content_hash=""
            break
        fi
        init_wait=$((init_wait + 2))
    done

    while true; do
        sleep 1

        # Check control inbox for new registration commands
        check_control_inbox

        # Check pane still exists
        if ! tmux list-panes -t "$pane_id" &>/dev/null; then
            break
        fi

        # Capture current pane content
        local content
        content=$(tmux capture-pane -t "$pane_id" -p -S -5 2>/dev/null) || continue

        # Hash the content to detect changes
        local current_hash
        current_hash=$(echo "$content" | md5sum | cut -d' ' -f1)

        if [[ "$current_hash" != "$last_content_hash" ]]; then
            idle_seconds=0
            bus_check_counter=0
            last_content_hash="$current_hash"

            # Check for plan mode immediately on content change
            # Plan mode blocks the worker — resolve it without waiting for idle
            if detect_plan_mode "$content"; then
                sleep 1
                tmux send-keys -t "$pane_id" '2'
                sleep 0.5
                tmux send-keys -t "$pane_id" Enter
                idle_seconds=0
                last_content_hash=""
                sleep 5
            fi
            continue
        fi

        # Also check for plan mode when content is stable (already idle)
        if detect_plan_mode "$content"; then
            tmux send-keys -t "$pane_id" '2'
            sleep 0.5
            tmux send-keys -t "$pane_id" Enter
            idle_seconds=0
            last_content_hash=""
            sleep 5
            continue
        fi

        idle_seconds=$((idle_seconds + 1))
        bus_check_counter=$((bus_check_counter + 1))

        # --- Track 1: Bus-aware fast check ---
        # Check bus and chat every BUS_CHECK_INTERVAL seconds.
        # Only inject /nbs-notify if something is actually pending.
        if [[ $bus_check_counter -ge $BUS_CHECK_INTERVAL ]]; then
            bus_check_counter=0

            if is_prompt_visible "$content"; then
                if should_inject_notify; then
                    tmux send-keys -t "$pane_id" -l "/nbs-notify ${NOTIFY_MESSAGE}"
                    sleep 0.3
                    tmux send-keys -t "$pane_id" Enter

                    # Verify injection was consumed: prompt should disappear
                    sleep 2
                    local verify_content
                    verify_content=$(tmux capture-pane -t "$pane_id" -p -S -5 2>/dev/null) || true
                    if is_prompt_visible "$verify_content"; then
                        # Prompt still visible — injection was not consumed, retry once
                        tmux send-keys -t "$pane_id" Enter
                        sleep 1
                    fi

                    idle_seconds=0
                    last_content_hash=""
                    sleep 8
                    continue
                fi
            fi
        fi

        # --- Track 2: Safety net poll ---
        # Full /nbs-poll after extended idle. Catches bus failures,
        # unregistered resources, anything the fast check missed.
        if [[ $idle_seconds -ge $POLL_INTERVAL ]]; then
            if is_prompt_visible "$content"; then
                tmux send-keys -t "$pane_id" -l '/nbs-poll'
                sleep 0.3
                tmux send-keys -t "$pane_id" Enter

                idle_seconds=0
                last_content_hash=""
                sleep 10
            else
                idle_seconds=0
            fi
        fi
    done
}

# --- Idle detection sidecar (pty-session mode) ---

poll_sidecar_pty() {
    local pty="$1"
    local session="$2"

    local idle_seconds=0
    local bus_check_counter=0
    local last_content_hash=""

    # Seed registry with existing resources
    seed_registry

    # Inject initial handle and chat skill prompt
    # Wait for Claude's prompt to appear, then tell it its handle
    local init_wait=0
    while [[ $init_wait -lt 60 ]]; do
        sleep 2
        local init_content
        init_content=$("$pty" read "$session" --scrollback=5 2>/dev/null) || true
        if echo "$init_content" | tail -3 | grep -qE '❯|>\s*$'; then
            "$pty" send "$session" "Your NBS handle is '${SIDECAR_HANDLE}'. Load /nbs-teams-chat. Use this handle for all nbs-chat send commands."
            sleep 0.5
            "$pty" send "$session" ''
            sleep 5
            last_content_hash=""
            break
        fi
        init_wait=$((init_wait + 2))
    done

    while true; do
        sleep 1

        # Check control inbox for new registration commands
        check_control_inbox

        if ! "$pty" list 2>/dev/null | grep -q "$session"; then
            break
        fi

        local content
        content=$("$pty" read "$session" --scrollback=5 2>/dev/null) || continue

        local current_hash
        current_hash=$(echo "$content" | md5sum | cut -d' ' -f1)

        if [[ "$current_hash" != "$last_content_hash" ]]; then
            idle_seconds=0
            bus_check_counter=0
            last_content_hash="$current_hash"

            # Check for plan mode immediately on content change
            if detect_plan_mode "$content"; then
                sleep 1
                "$pty" send "$session" --no-enter '2'
                sleep 0.5
                "$pty" send "$session" ''
                idle_seconds=0
                last_content_hash=""
                sleep 5
            fi
            continue
        fi

        # Check for plan mode when content is stable
        if detect_plan_mode "$content"; then
            "$pty" send "$session" --no-enter '2'
            sleep 0.5
            "$pty" send "$session" ''
            idle_seconds=0
            last_content_hash=""
            sleep 5
            continue
        fi

        idle_seconds=$((idle_seconds + 1))
        bus_check_counter=$((bus_check_counter + 1))

        # --- Track 1: Bus-aware fast check ---
        if [[ $bus_check_counter -ge $BUS_CHECK_INTERVAL ]]; then
            bus_check_counter=0

            if is_prompt_visible "$content"; then
                if should_inject_notify; then
                    "$pty" send "$session" "/nbs-notify ${NOTIFY_MESSAGE}"
                    sleep 0.5
                    "$pty" send "$session" ''

                    # Verify injection was consumed: prompt should disappear
                    sleep 2
                    local verify_content
                    verify_content=$("$pty" read "$session" --scrollback=5 2>/dev/null) || true
                    if is_prompt_visible "$verify_content"; then
                        # Prompt still visible — injection was not consumed, retry once
                        "$pty" send "$session" ''
                        sleep 1
                    fi

                    idle_seconds=0
                    last_content_hash=""
                    sleep 8
                    continue
                fi
            fi
        fi

        # --- Track 2: Safety net poll ---
        if [[ $idle_seconds -ge $POLL_INTERVAL ]]; then
            if is_prompt_visible "$content"; then
                "$pty" send "$session" '/nbs-poll'
                sleep 0.5
                "$pty" send "$session" ''

                idle_seconds=0
                last_content_hash=""
                sleep 10
            else
                idle_seconds=0
            fi
        fi
    done
}

# --- Main ---

# Build claude command with args (intercept --root= for sidecar)
CLAUDE_ARGS=("claude")
for arg in "$@"; do
    case "$arg" in
        --root=*)
            NBS_ROOT="${arg#--root=}"
            ;;
        *)
            CLAUDE_ARGS+=("$arg")
            ;;
    esac
done

echo "Starting Claude Code with NBS bus-aware polling..."
echo "  Bus check interval: ${BUS_CHECK_INTERVAL}s"
echo "  Notify cooldown: ${NOTIFY_COOLDOWN}s"
echo "  Safety net poll: ${POLL_INTERVAL}s idle"
echo "  Handle: ${SIDECAR_HANDLE}"
echo "  Root: ${NBS_ROOT}"
if [[ "$POLL_DISABLE" == "1" ]]; then
    echo "  Polling: DISABLED"
fi

if [[ -n "${TMUX:-}" ]]; then
    # --- Already inside tmux ---
    MODE="tmux"

    # Get current pane ID before launching claude
    PANE_ID=$(tmux display-message -p '#{pane_id}')
    echo "  Mode: tmux (pane $PANE_ID)"
    echo ""

    # Start sidecar monitoring this pane
    if [[ "$POLL_DISABLE" != "1" ]]; then
        poll_sidecar_tmux "$PANE_ID" &
        SIDECAR_PID=$!
    fi

    # Run claude in foreground — replaces this process's foreground
    # but the sidecar is already running in background
    "${CLAUDE_ARGS[@]}"

    # Claude exited — cleanup runs via trap
else
    # --- Not inside tmux ---
    MODE="pty"
    SESSION_NAME="nbs-claude-$$"

    echo "  Mode: pty-session ($SESSION_NAME)"
    echo ""

    # Build command string for pty-session (skip --root= which is sidecar-only)
    CLAUDE_CMD="claude"
    if [[ $# -gt 0 ]]; then
        CLAUDE_CMD_ARGS=""
        for arg in "$@"; do
            case "$arg" in --root=*) continue ;; esac
            if [[ -z "$CLAUDE_CMD_ARGS" ]]; then
                CLAUDE_CMD_ARGS="$(printf '%q' "$arg")"
            else
                CLAUDE_CMD_ARGS="$CLAUDE_CMD_ARGS $(printf '%q' "$arg")"
            fi
        done
        CLAUDE_CMD="claude $CLAUDE_CMD_ARGS"
    fi

    # Create pty-session running claude
    "$PTY_SESSION" create "$SESSION_NAME" "$CLAUDE_CMD"

    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to create pty-session" >&2
        exit 1
    fi

    # Start sidecar if polling enabled
    if [[ "$POLL_DISABLE" != "1" ]]; then
        poll_sidecar_pty "$PTY_SESSION" "$SESSION_NAME" &
        SIDECAR_PID=$!
    fi

    # Attach to the session
    tmux attach-session -t "pty_${SESSION_NAME}"
fi

# When user exits, cleanup runs via trap
