#!/bin/bash
# nbs-claude: Launch Claude Code with automatic chat/worker polling
#
# Wraps `claude` in a pty-session with a sidecar that monitors for idle
# state and injects /nbs-poll when claude is waiting for user input.
#
# Usage:
#   nbs-claude [claude-args...]
#
# Examples:
#   nbs-claude                    # Start interactive claude
#   nbs-claude -p "fix the bug"  # Pass arguments through
#
# Environment:
#   NBS_POLL_INTERVAL  Seconds of idle before injecting poll (default: 30)
#   NBS_POLL_DISABLE   Set to 1 to disable polling (just wraps claude)
#
# Exit codes:
#   0 - Clean exit
#   1 - General error
#   4 - Invalid arguments

set -uo pipefail

# --- Configuration ---

POLL_INTERVAL="${NBS_POLL_INTERVAL:-30}"
POLL_DISABLE="${NBS_POLL_DISABLE:-0}"

# Resolve tools
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PTY_SESSION="${SCRIPT_DIR}/pty-session"

if [[ ! -x "$PTY_SESSION" ]]; then
    # Try installed location
    PTY_SESSION="${HOME}/.nbs/bin/pty-session"
fi

if [[ ! -x "$PTY_SESSION" ]]; then
    echo "Error: pty-session not found" >&2
    exit 1
fi

# Session name — unique per invocation to allow multiple instances
SESSION_NAME="nbs-claude-$$"

# --- Cleanup ---

cleanup() {
    # Kill sidecar if running
    if [[ -n "${SIDECAR_PID:-}" ]] && kill -0 "$SIDECAR_PID" 2>/dev/null; then
        kill "$SIDECAR_PID" 2>/dev/null
        wait "$SIDECAR_PID" 2>/dev/null
    fi

    # Kill the pty-session
    "$PTY_SESSION" kill "$SESSION_NAME" 2>/dev/null

    exit 0
}
trap cleanup INT TERM EXIT

# --- Idle detection sidecar ---

poll_sidecar() {
    local pty="$1"
    local session="$2"
    local interval="$3"

    local idle_seconds=0
    local last_content_hash=""

    while true; do
        sleep 1

        # Check session is still alive
        if ! "$pty" list 2>/dev/null | grep -q "$session"; then
            break
        fi

        # Capture current screen content
        local content
        content=$("$pty" read "$session" --scrollback=5 2>/dev/null) || continue

        # Hash the content to detect changes
        local current_hash
        current_hash=$(echo "$content" | md5sum | cut -d' ' -f1)

        if [[ "$current_hash" != "$last_content_hash" ]]; then
            # Screen changed — reset idle counter
            idle_seconds=0
            last_content_hash="$current_hash"
            continue
        fi

        # Screen unchanged — increment idle counter
        idle_seconds=$((idle_seconds + 1))

        if [[ $idle_seconds -ge $interval ]]; then
            # Check if claude appears to be at a prompt (waiting for input)
            # Look for the prompt indicator in the last few lines
            if echo "$content" | tail -3 | grep -qE '❯|>\s*$'; then
                # Inject /nbs-poll
                "$pty" send "$session" '/nbs-poll'
                sleep 0.5
                "$pty" send "$session" ''

                # Reset idle counter — give claude time to process
                idle_seconds=0
                # Update hash so we don't re-trigger immediately
                last_content_hash=""

                # Wait for poll to complete before resuming idle detection
                sleep 10
            else
                # Not at prompt — reset and wait
                idle_seconds=0
            fi
        fi
    done
}

# --- Main ---

# Build claude command
CLAUDE_CMD="claude"
if [[ $# -gt 0 ]]; then
    # Quote args for safe passing
    CLAUDE_ARGS=""
    for arg in "$@"; do
        if [[ -z "$CLAUDE_ARGS" ]]; then
            CLAUDE_ARGS="$(printf '%q' "$arg")"
        else
            CLAUDE_ARGS="$CLAUDE_ARGS $(printf '%q' "$arg")"
        fi
    done
    CLAUDE_CMD="claude $CLAUDE_ARGS"
fi

echo "Starting Claude Code with NBS polling..."
echo "  Session: $SESSION_NAME"
echo "  Poll interval: ${POLL_INTERVAL}s idle"
if [[ "$POLL_DISABLE" == "1" ]]; then
    echo "  Polling: DISABLED"
fi
echo ""

# Create pty-session running claude
"$PTY_SESSION" create "$SESSION_NAME" "$CLAUDE_CMD"

if [[ $? -ne 0 ]]; then
    echo "Error: Failed to create pty-session" >&2
    exit 1
fi

# Start sidecar if polling enabled
SIDECAR_PID=""
if [[ "$POLL_DISABLE" != "1" ]]; then
    poll_sidecar "$PTY_SESSION" "$SESSION_NAME" "$POLL_INTERVAL" &
    SIDECAR_PID=$!
fi

# Attach to the session interactively
# This gives the user direct terminal access to claude
tmux attach-session -t "pty_${SESSION_NAME}"

# When user detaches or claude exits, cleanup runs via trap
