#!/bin/bash
# nbs-claude: Launch Claude Code with automatic chat/worker polling
#
# Runs claude with a background sidecar that monitors for idle state
# and injects /nbs-poll when claude is waiting for user input.
#
# Works in two modes:
#   - Inside tmux: runs claude in the current pane, sidecar monitors it
#   - Outside tmux: creates a pty-session, attaches to it
#
# Usage:
#   nbs-claude [claude-args...]
#
# Examples:
#   nbs-claude                    # Start interactive claude
#   nbs-claude --resume abc123   # Resume session with polling
#
# Environment:
#   NBS_POLL_INTERVAL  Seconds of idle before injecting poll (default: 30)
#   NBS_POLL_DISABLE   Set to 1 to disable polling (just wraps claude)
#
# Exit codes:
#   0 - Clean exit
#   1 - General error
#   4 - Invalid arguments

set -uo pipefail

# --- Configuration ---

POLL_INTERVAL="${NBS_POLL_INTERVAL:-30}"
POLL_DISABLE="${NBS_POLL_DISABLE:-0}"

# Resolve tools
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PTY_SESSION="${SCRIPT_DIR}/pty-session"

if [[ ! -x "$PTY_SESSION" ]]; then
    PTY_SESSION="${HOME}/.nbs/bin/pty-session"
fi

if [[ ! -x "$PTY_SESSION" ]]; then
    echo "Error: pty-session not found" >&2
    exit 1
fi

# --- Cleanup ---

SIDECAR_PID=""
SESSION_NAME=""
MODE=""

cleanup() {
    # Kill sidecar if running
    if [[ -n "$SIDECAR_PID" ]] && kill -0 "$SIDECAR_PID" 2>/dev/null; then
        kill "$SIDECAR_PID" 2>/dev/null
        wait "$SIDECAR_PID" 2>/dev/null
    fi

    # Kill pty-session if we created one
    if [[ "$MODE" == "pty" && -n "$SESSION_NAME" ]]; then
        "$PTY_SESSION" kill "$SESSION_NAME" 2>/dev/null
    fi

    exit 0
}
trap cleanup INT TERM EXIT

# --- Plan mode detection ---
# Claude Code's plan mode displays an interactive menu that blocks execution.
# The sidecar detects this prompt and auto-selects option 2 ("Yes, and bypass
# permissions") so unattended workers are not blocked indefinitely.

detect_plan_mode() {
    local content="$1"
    echo "$content" | grep -qF 'Would you like to proceed?'
}

# --- Idle detection sidecar (tmux mode) ---
# Monitors the current tmux pane for idle and injects /nbs-poll

poll_sidecar_tmux() {
    local interval="$1"
    local pane_id="$2"

    local idle_seconds=0
    local last_content_hash=""

    while true; do
        sleep 1

        # Check pane still exists
        if ! tmux list-panes -t "$pane_id" &>/dev/null; then
            break
        fi

        # Capture current pane content
        local content
        content=$(tmux capture-pane -t "$pane_id" -p -S -5 2>/dev/null) || continue

        # Hash the content to detect changes
        local current_hash
        current_hash=$(echo "$content" | md5sum | cut -d' ' -f1)

        if [[ "$current_hash" != "$last_content_hash" ]]; then
            idle_seconds=0
            last_content_hash="$current_hash"

            # Check for plan mode immediately on content change
            # Plan mode blocks the worker — resolve it without waiting for idle
            if detect_plan_mode "$content"; then
                sleep 1
                tmux send-keys -t "$pane_id" '2'
                sleep 0.5
                tmux send-keys -t "$pane_id" Enter
                idle_seconds=0
                last_content_hash=""
                sleep 5
            fi
            continue
        fi

        # Also check for plan mode when content is stable (already idle)
        if detect_plan_mode "$content"; then
            tmux send-keys -t "$pane_id" '2'
            sleep 0.5
            tmux send-keys -t "$pane_id" Enter
            idle_seconds=0
            last_content_hash=""
            sleep 5
            continue
        fi

        idle_seconds=$((idle_seconds + 1))

        if [[ $idle_seconds -ge $interval ]]; then
            # Check if claude appears to be at a prompt
            if echo "$content" | tail -3 | grep -qE '❯|>\s*$'; then
                # Inject /nbs-poll followed by Enter
                # Send text first, small delay, then Enter separately
                # Claude Code may not process pasted text + Enter atomically
                tmux send-keys -t "$pane_id" -l '/nbs-poll'
                sleep 0.3
                tmux send-keys -t "$pane_id" Enter

                idle_seconds=0
                last_content_hash=""

                # Wait for poll to complete
                sleep 10
            else
                idle_seconds=0
            fi
        fi
    done
}

# --- Idle detection sidecar (pty-session mode) ---

poll_sidecar_pty() {
    local pty="$1"
    local session="$2"
    local interval="$3"

    local idle_seconds=0
    local last_content_hash=""

    while true; do
        sleep 1

        if ! "$pty" list 2>/dev/null | grep -q "$session"; then
            break
        fi

        local content
        content=$("$pty" read "$session" --scrollback=5 2>/dev/null) || continue

        local current_hash
        current_hash=$(echo "$content" | md5sum | cut -d' ' -f1)

        if [[ "$current_hash" != "$last_content_hash" ]]; then
            idle_seconds=0
            last_content_hash="$current_hash"

            # Check for plan mode immediately on content change
            if detect_plan_mode "$content"; then
                sleep 1
                "$pty" send "$session" --no-enter '2'
                sleep 0.5
                "$pty" send "$session" ''
                idle_seconds=0
                last_content_hash=""
                sleep 5
            fi
            continue
        fi

        # Check for plan mode when content is stable
        if detect_plan_mode "$content"; then
            "$pty" send "$session" --no-enter '2'
            sleep 0.5
            "$pty" send "$session" ''
            idle_seconds=0
            last_content_hash=""
            sleep 5
            continue
        fi

        idle_seconds=$((idle_seconds + 1))

        if [[ $idle_seconds -ge $interval ]]; then
            if echo "$content" | tail -3 | grep -qE '❯|>\s*$'; then
                "$pty" send "$session" '/nbs-poll'
                sleep 0.5
                "$pty" send "$session" ''

                idle_seconds=0
                last_content_hash=""
                sleep 10
            else
                idle_seconds=0
            fi
        fi
    done
}

# --- Main ---

# Build claude command with args
CLAUDE_ARGS=("claude")
for arg in "$@"; do
    CLAUDE_ARGS+=("$arg")
done

echo "Starting Claude Code with NBS polling..."
echo "  Poll interval: ${POLL_INTERVAL}s idle"
if [[ "$POLL_DISABLE" == "1" ]]; then
    echo "  Polling: DISABLED"
fi

if [[ -n "${TMUX:-}" ]]; then
    # --- Already inside tmux ---
    MODE="tmux"

    # Get current pane ID before launching claude
    PANE_ID=$(tmux display-message -p '#{pane_id}')
    echo "  Mode: tmux (pane $PANE_ID)"
    echo ""

    # Start sidecar monitoring this pane
    if [[ "$POLL_DISABLE" != "1" ]]; then
        poll_sidecar_tmux "$POLL_INTERVAL" "$PANE_ID" &
        SIDECAR_PID=$!
    fi

    # Run claude in foreground — replaces this process's foreground
    # but the sidecar is already running in background
    "${CLAUDE_ARGS[@]}"

    # Claude exited — cleanup runs via trap
else
    # --- Not inside tmux ---
    MODE="pty"
    SESSION_NAME="nbs-claude-$$"

    echo "  Mode: pty-session ($SESSION_NAME)"
    echo ""

    # Build command string for pty-session
    CLAUDE_CMD="claude"
    if [[ $# -gt 0 ]]; then
        CLAUDE_CMD_ARGS=""
        for arg in "$@"; do
            if [[ -z "$CLAUDE_CMD_ARGS" ]]; then
                CLAUDE_CMD_ARGS="$(printf '%q' "$arg")"
            else
                CLAUDE_CMD_ARGS="$CLAUDE_CMD_ARGS $(printf '%q' "$arg")"
            fi
        done
        CLAUDE_CMD="claude $CLAUDE_CMD_ARGS"
    fi

    # Create pty-session running claude
    "$PTY_SESSION" create "$SESSION_NAME" "$CLAUDE_CMD"

    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to create pty-session" >&2
        exit 1
    fi

    # Start sidecar if polling enabled
    if [[ "$POLL_DISABLE" != "1" ]]; then
        poll_sidecar_pty "$PTY_SESSION" "$SESSION_NAME" "$POLL_INTERVAL" &
        SIDECAR_PID=$!
    fi

    # Attach to the session
    tmux attach-session -t "pty_${SESSION_NAME}"
fi

# When user exits, cleanup runs via trap
