#!/bin/bash
# nbs-claude: Launch Claude Code with bus-aware event-driven notification
#
# Runs claude with a background sidecar that:
#   1. Checks the event bus every few seconds for pending events
#   2. Checks chat cursors for unread messages
#   3. Injects /nbs-notify only when there is something to process
#   4. Injects /nbs-poll as a safety net after extended idle (5 min)
#   5. Auto-selects plan mode prompts for unattended workers
#
# Works in two modes:
#   - Inside tmux: runs claude in the current pane, sidecar monitors it
#   - Outside tmux: creates a pty-session, attaches to it
#
# Usage:
#   nbs-claude [--root=PATH] [claude-args...]
#
# Examples:
#   nbs-claude                    # Start interactive claude
#   nbs-claude --resume abc123   # Resume session with polling
#   nbs-claude --root=/path/to/project  # Use .nbs/ from another directory
#
# Environment:
#   NBS_POLL_INTERVAL       Safety net poll interval in seconds (default: 300)
#   NBS_POLL_DISABLE        Set to 1 to disable all polling (just wraps claude)
#   NBS_BUS_CHECK_INTERVAL  Bus/chat check interval in seconds (default: 3)
#   NBS_NOTIFY_COOLDOWN     Min seconds between /nbs-notify injections (default: 15)
#   NBS_HANDLE              Agent handle for cursor peeking (default: claude)
#   NBS_ROOT                Project root containing .nbs/ (default: current directory)
#   NBS_STARTUP_GRACE       Seconds after init before allowing notifications (default: 30)
#   NBS_INITIAL_PROMPT      Custom initial prompt (default: handle + /nbs-teams-chat)
#   NBS_NOTIFY_FAIL_THRESHOLD  Failed /nbs-notify injections before self-heal (default: 5)
#
# Exit codes:
#   0 - Clean exit
#   1 - General error
#   4 - Invalid arguments

set -euo pipefail

# --- Configuration ---

POLL_INTERVAL="${NBS_POLL_INTERVAL:-300}"
POLL_DISABLE="${NBS_POLL_DISABLE:-0}"
BUS_CHECK_INTERVAL="${NBS_BUS_CHECK_INTERVAL:-3}"
NOTIFY_COOLDOWN="${NBS_NOTIFY_COOLDOWN:-15}"
SIDECAR_HANDLE="${NBS_HANDLE:-claude}"
NBS_ROOT="${NBS_ROOT:-.}"
STARTUP_GRACE="${NBS_STARTUP_GRACE:-30}"
INITIAL_PROMPT="${NBS_INITIAL_PROMPT:-}"
NOTIFY_FAIL_THRESHOLD="${NBS_NOTIFY_FAIL_THRESHOLD:-5}"

# Resolve NBS_ROOT to absolute path
NBS_ROOT="$(cd "$NBS_ROOT" 2>/dev/null && pwd)" || {
    echo "Error: NBS_ROOT directory does not exist: ${NBS_ROOT:-<unset>}" >&2
    exit 1
}

# Validate numeric config variables
for _nbs_var_name in POLL_INTERVAL POLL_DISABLE BUS_CHECK_INTERVAL NOTIFY_COOLDOWN STARTUP_GRACE NOTIFY_FAIL_THRESHOLD; do
    eval "_nbs_var_val=\${$_nbs_var_name}"
    if [[ ! "$_nbs_var_val" =~ ^[0-9]+$ ]]; then
        echo "Error: $_nbs_var_name must be a non-negative integer, got '$_nbs_var_val'" >&2
        exit 4
    fi
done
unset _nbs_var_name _nbs_var_val

# Validate SIDECAR_HANDLE: must be safe for tmux send-keys and file paths
if [[ ! "$SIDECAR_HANDLE" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    echo "Error: NBS_HANDLE must match ^[a-zA-Z0-9_-]+\$, got '$SIDECAR_HANDLE'" >&2
    exit 4
fi
NBS_REMOTE_HOST="${NBS_REMOTE_HOST:-}"
NBS_REMOTE_SSH_OPTS="${NBS_REMOTE_SSH_OPTS:-}"

# Log file for stderr redirection (instead of /dev/null)
NBS_LOG_FILE="${NBS_ROOT}/.nbs/nbs-claude-$$.log"

# Resolve tools
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PTY_SESSION="${SCRIPT_DIR}/pty-session"

if [[ ! -x "$PTY_SESSION" ]]; then
    PTY_SESSION="${HOME}/.nbs/bin/pty-session"
fi

if [[ ! -x "$PTY_SESSION" ]]; then
    echo "Error: pty-session not found" >&2
    exit 1
fi

# --- Cleanup ---

SIDECAR_PID=""
SESSION_NAME=""
MODE=""

cleanup() {
    local EXIT_CODE=$?

    # Kill sidecar if running
    if [[ -n "$SIDECAR_PID" ]] && kill -0 "$SIDECAR_PID" 2>/dev/null; then
        kill "$SIDECAR_PID" 2>/dev/null || true
        wait "$SIDECAR_PID" 2>/dev/null || true
    fi

    # Kill pty-session if we created one
    if [[ "$MODE" == "pty" && -n "$SESSION_NAME" ]]; then
        "$PTY_SESSION" kill "$SESSION_NAME" 2>/dev/null || true
    fi

    exit "$EXIT_CODE"
}
trap cleanup INT TERM EXIT

# --- Plan mode detection ---
# Claude Code's plan mode displays an interactive menu that blocks execution.
# The sidecar detects this prompt and auto-selects option 2 ("Yes, and bypass
# permissions") so unattended workers are not blocked indefinitely.

detect_plan_mode() {
    local content="$1"
    echo "$content" | grep -qF 'Would you like to proceed?'
}

# --- AskUserQuestion modal detection ---
# The AskUserQuestion tool presents a blocking modal with numbered options.
# In multi-agent setups no human is watching, so the agent stalls indefinitely.
# The sidecar detects this modal and auto-selects option 1 (the default/recommended
# choice) to unblock the agent. The agent should not use AskUserQuestion at all
# (skill prompts prohibit it), but this is a safety net for when it slips through.

detect_ask_modal() {
    local content="$1"
    # AskUserQuestion shows "? N. <label>" options followed by "Type something."
    # The combination of numbered options and "Type something" is distinctive.
    echo "$content" | grep -qF 'Type something.' && \
    echo "$content" | grep -qE '^\s*[?>]?\s*[1-4]\.' && return 0
    return 1
}

# --- Context stress detection ---
# Claude Code displays specific messages when context is stressed:
#   - "Compacting conversation" during auto-compact
#   - "Conversation too long" when compact fails (cannot compact further)
#   - "Prompt is too long" when the API rejects input
#   - "Error compacting conversation" on compact error
# When any of these are visible, the sidecar must NOT inject commands
# as they will fail and waste remaining context, creating an infinite loop.

detect_context_stress() {
    local content="$1"
    echo "$content" | grep -qF 'Compacting conversation' && return 0
    echo "$content" | grep -qF 'Conversation too long' && return 0
    echo "$content" | grep -qF 'Prompt is too long' && return 0
    echo "$content" | grep -qF 'Error compacting conversation' && return 0
    return 1
}

# detect_skill_failure — check if Claude rejected the last injection as an unknown skill.
# Returns: 0 = skill failure detected, 1 = no failure.
detect_skill_failure() {
    local content="$1"
    echo "$content" | grep -qF 'Unknown skill' && return 0
    return 1
}

# build_recovery_prompt — construct a raw text prompt that re-bootstraps the agent
# without depending on registered skills. Uses absolute paths to skill files.
# This is the self-healing fallback when /nbs-notify is rejected repeatedly.
build_recovery_prompt() {
    local notify_skill="${NBS_ROOT}/claude_tools/nbs-notify.md"
    local chat_skill="${NBS_ROOT}/claude_tools/nbs-teams-chat.md"
    local poll_skill="${NBS_ROOT}/claude_tools/nbs-poll.md"

    # Find available chat files for the active announcement
    local chat_files=""
    if [[ -f "$CONTROL_REGISTRY" ]]; then
        while IFS= read -r line; do
            case "$line" in
                chat:*) chat_files="${chat_files} ${line#chat:}" ;;
            esac
        done < "$CONTROL_REGISTRY"
    fi

    # Build the prompt with absolute paths
    local prompt="Your skills were lost after compaction. Please read these files to restore them: "
    prompt+="$(realpath "$notify_skill" 2>/dev/null || echo "$notify_skill")"
    prompt+=", $(realpath "$chat_skill" 2>/dev/null || echo "$chat_skill")"
    prompt+=", $(realpath "$poll_skill" 2>/dev/null || echo "$poll_skill")"
    prompt+=". Your handle is '${SIDECAR_HANDLE}'. "

    if [[ -n "$chat_files" ]]; then
        local first_chat
        first_chat=$(echo "$chat_files" | awk '{print $1}')
        prompt+="Then send a message to ${first_chat} using: nbs-chat send ${first_chat} ${SIDECAR_HANDLE} 'active — skills restored after compaction recovery'."
    fi

    echo "$prompt"
}

# --- Dynamic resource registration ---
# The AI declares what resources it needs by writing to .nbs/control-inbox-<handle>.
# The sidecar reads new lines (forward-only, never truncates) and maintains
# a resource registry at .nbs/control-registry-<handle>.
#
# Convention: / = human-to-AI, \ = AI-to-wrapper
# The AI outputs \nbs-register-chat etc. which writes to the control inbox.
# See feature-requests/dynamic-registration.md for full design.

CONTROL_INBOX="${NBS_ROOT}/.nbs/control-inbox-${SIDECAR_HANDLE}"
CONTROL_REGISTRY="${NBS_ROOT}/.nbs/control-registry-${SIDECAR_HANDLE}"
CONTROL_INBOX_LINE=0

# --- Remote execution helper ---
# When NBS_REMOTE_HOST is set, commands that access .nbs/ files run over SSH.
# When empty, commands run locally (normal mode).

remote_cmd() {
    if [[ -n "$NBS_REMOTE_HOST" ]]; then
        local ssh_cmd=(ssh -o ControlPath=none -o BatchMode=yes -o ConnectTimeout=5)
        if [[ -n "$NBS_REMOTE_SSH_OPTS" ]]; then
            local ssh_opts
            IFS=' ' read -ra ssh_opts <<< "$NBS_REMOTE_SSH_OPTS"
            ssh_cmd+=("${ssh_opts[@]}")
        fi
        ssh_cmd+=("$NBS_REMOTE_HOST" "$@")
        "${ssh_cmd[@]}" 2>>"${NBS_LOG_FILE}"
    else
        "$@" 2>>"${NBS_LOG_FILE}"
    fi
}

# is_remote — returns 0 if running in remote mode
is_remote() {
    [[ -n "$NBS_REMOTE_HOST" ]]
}

# seed_registry — populate registry from existing .nbs/ resources on startup.
# Idempotent: skips resources already registered.
seed_registry() {
    # Create registry file if it does not exist (always local)
    mkdir -p "$(dirname "$CONTROL_REGISTRY")"
    touch "$CONTROL_REGISTRY"

    if is_remote; then
        # Remote mode: discover resources via SSH
        local remote_chats
        remote_chats=$(remote_cmd "ls $(printf '%q' "${NBS_ROOT}")/.nbs/chat/*.chat 2>/dev/null") || true
        while IFS= read -r chat; do
            [[ -z "$chat" ]] && continue
            if ! grep -qF "chat:${chat}" "$CONTROL_REGISTRY" 2>/dev/null; then
                echo "chat:${chat}" >> "$CONTROL_REGISTRY"
            fi
        done <<< "$remote_chats"

        # Register bus directory if it exists on remote
        if remote_cmd "test -d $(printf '%q' "${NBS_ROOT}")/.nbs/events" 2>/dev/null; then
            if ! grep -qF "bus:${NBS_ROOT}/.nbs/events" "$CONTROL_REGISTRY" 2>/dev/null; then
                echo "bus:${NBS_ROOT}/.nbs/events" >> "$CONTROL_REGISTRY"
            fi
        fi
    else
        # Local mode: direct file access
        for chat in "${NBS_ROOT}"/.nbs/chat/*.chat; do
            [[ -f "$chat" ]] || continue
            if ! grep -qF "chat:${chat}" "$CONTROL_REGISTRY" 2>/dev/null; then
                echo "chat:${chat}" >> "$CONTROL_REGISTRY"
            fi
        done

        if [[ -d "${NBS_ROOT}/.nbs/events" ]]; then
            if ! grep -qF "bus:${NBS_ROOT}/.nbs/events" "$CONTROL_REGISTRY" 2>/dev/null; then
                echo "bus:${NBS_ROOT}/.nbs/events" >> "$CONTROL_REGISTRY"
            fi
        fi
    fi
}

# process_control_command — handle a single control command line.
# Precondition: line is non-empty and has been stripped of whitespace.
# Postcondition: registry is updated if command is valid; invalid lines are ignored.
process_control_command() {
    local line="$1"
    local verb path

    verb=$(echo "$line" | awk '{print $1}')
    path=$(echo "$line" | awk '{print $2}')

    # Require both verb and path
    [[ -z "$verb" || -z "$path" ]] && return 0

    case "$verb" in
        register-chat)
            if ! grep -qF "chat:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                echo "chat:${path}" >> "$CONTROL_REGISTRY"
                echo "[nbs-claude] Registered chat: $path" >&2
            fi
            ;;
        unregister-chat)
            if grep -qF "chat:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                { grep -vF "chat:${path}" "$CONTROL_REGISTRY" || true; } > "${CONTROL_REGISTRY}.tmp"
                mv "${CONTROL_REGISTRY}.tmp" "$CONTROL_REGISTRY"
                echo "[nbs-claude] Unregistered chat: $path" >&2
            fi
            ;;
        register-bus)
            if ! grep -qF "bus:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                echo "bus:${path}" >> "$CONTROL_REGISTRY"
                echo "[nbs-claude] Registered bus: $path" >&2
            fi
            ;;
        unregister-bus)
            if grep -qF "bus:${path}" "$CONTROL_REGISTRY" 2>/dev/null; then
                { grep -vF "bus:${path}" "$CONTROL_REGISTRY" || true; } > "${CONTROL_REGISTRY}.tmp"
                mv "${CONTROL_REGISTRY}.tmp" "$CONTROL_REGISTRY"
                echo "[nbs-claude] Unregistered bus: $path" >&2
            fi
            ;;
        set-poll-interval)
            # Validate: must be a positive integer
            if [[ "$path" =~ ^[0-9]+$ ]] && [[ "$path" -gt 0 ]]; then
                POLL_INTERVAL="$path"
                echo "[nbs-claude] Poll interval set to ${path}s" >&2
            fi
            ;;
        *)
            # Unknown command — log to stderr for debugging
            echo "[nbs-claude] Unknown control command: $verb" >&2
            ;;
    esac
}

# check_control_inbox — process new lines from the control inbox.
# Forward-only: tracks line offset, never re-processes old lines, never truncates.
# Called every sidecar iteration (1 second).
check_control_inbox() {
    [[ -f "$CONTROL_INBOX" ]] || return 0

    # Read file atomically into variable to avoid TOCTOU race
    # between wc -l and tail.
    # Note: $(<file 2>/dev/null) is broken in bash <5.2 — the redirect
    # interferes with the internal read mechanism, producing empty output.
    # Use $(cat ...) instead.
    local inbox_content
    inbox_content=$(cat "$CONTROL_INBOX" 2>/dev/null) || return 0
    [[ -n "$inbox_content" ]] || return 0

    local total_lines
    total_lines=$(printf '%s\n' "$inbox_content" | wc -l)
    total_lines=$((total_lines + 0))  # ensure numeric

    if [[ $total_lines -gt $CONTROL_INBOX_LINE ]]; then
        local new_lines
        new_lines=$(printf '%s\n' "$inbox_content" | tail -n +"$((CONTROL_INBOX_LINE + 1))")

        while IFS= read -r line; do
            # Strip leading/trailing whitespace
            line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            [[ -z "$line" ]] && continue
            # Skip comment lines
            [[ "$line" == \#* ]] && continue
            process_control_command "$line"
        done <<< "$new_lines"

        CONTROL_INBOX_LINE=$total_lines
    fi
}

# --- Bus-aware event checking ---
# The sidecar checks the bus and chat cursors directly, injecting /nbs-notify
# only when there is something to process. This replaces blind /nbs-poll
# injection which wastes context on empty checks.

# Globals set by check functions
BUS_EVENT_COUNT=0
BUS_MAX_PRIORITY="none"
BUS_EVENT_SUMMARY=""
CHAT_UNREAD_COUNT=0
CHAT_UNREAD_SUMMARY=""
NOTIFY_MESSAGE=""
LAST_NOTIFY_TIME=0
SIDECAR_START_TIME=0
NOTIFY_FAIL_COUNT=0

# check_bus_events — peek at the event bus without consuming anything.
# Reads the control registry for bus: entries, runs nbs-bus check on each.
# Sets BUS_EVENT_COUNT, BUS_MAX_PRIORITY, BUS_EVENT_SUMMARY.
# Returns: 0 = events found, 1 = empty, 2 = no bus registered.
check_bus_events() {
    BUS_EVENT_COUNT=0
    BUS_MAX_PRIORITY="none"
    BUS_EVENT_SUMMARY=""

    [[ -f "$CONTROL_REGISTRY" ]] || return 2

    local has_bus=0
    local output

    while IFS= read -r line; do
        case "$line" in
            bus:*)
                local bus_dir="${line#bus:}"
                if is_remote; then
                    has_bus=1
                    output=$(remote_cmd "nbs-bus check $(printf '%q' "$bus_dir")") || continue
                elif [[ -d "$bus_dir" ]]; then
                    has_bus=1
                    output=$(nbs-bus check "$bus_dir" 2>/dev/null) || continue
                else
                    continue
                fi
                    if [[ -n "$output" ]]; then
                        BUS_EVENT_COUNT=$(echo "$output" | wc -l)
                        BUS_EVENT_COUNT=$((BUS_EVENT_COUNT + 0))
                        # Extract highest priority (first line, first bracket group)
                        BUS_MAX_PRIORITY=$(echo "$output" | head -1 | sed 's/^\[\([a-z]*\)\].*/\1/')
                        BUS_EVENT_SUMMARY="${BUS_EVENT_COUNT} event(s) in ${bus_dir}"
                    fi
                ;;
        esac
    done < "$CONTROL_REGISTRY"

    [[ $has_bus -eq 0 ]] && return 2
    [[ $BUS_EVENT_COUNT -eq 0 ]] && return 1
    return 0
}

# check_chat_unread — peek at chat cursors without advancing them.
# Reads cursor files directly (no lock, no modification) and compares
# against total message count. Format: handle=index in <chat>.cursors.
# See src/nbs-chat/chat_file.c for cursor file format.
# Sets CHAT_UNREAD_COUNT, CHAT_UNREAD_SUMMARY.
# Returns: 0 = unread found, 1 = caught up, 2 = no chats registered.
check_chat_unread() {
    CHAT_UNREAD_COUNT=0
    CHAT_UNREAD_SUMMARY=""

    [[ -f "$CONTROL_REGISTRY" ]] || return 2

    local has_chat=0
    local unread_chats=""

    while IFS= read -r line; do
        case "$line" in
            chat:*)
                local chat_path="${line#chat:}"

                if is_remote; then
                    # Remote mode: check file existence and read via SSH
                    remote_cmd "test -f $(printf '%q' "$chat_path")" || continue
                    has_chat=1

                    local total
                    total=$(remote_cmd "awk '/^---\$/{found=1; next} found && NF{count++} END{print count+0}' $(printf '%q' "$chat_path")")
                    total=$((${total:-0} + 0))

                    local cursor=0
                    local cursor_val
                    cursor_val=$(remote_cmd "awk -F= -v h='$SIDECAR_HANDLE' '\$1==h{print \$2}' $(printf '%q' "${chat_path}.cursors") 2>/dev/null") || true
                    cursor=$((${cursor_val:-0} + 0))
                else
                    # Local mode: direct file access
                    [[ -f "$chat_path" ]] || continue
                    has_chat=1

                    local total
                    total=$(awk '/^---$/{found=1; next} found && NF{count++} END{print count+0}' "$chat_path" 2>/dev/null) || true
                    total=$((${total:-0} + 0))

                    local cursor=0
                    if [[ -f "${chat_path}.cursors" ]]; then
                        cursor=$(awk -F= -v h="$SIDECAR_HANDLE" '$1==h{print $2}' "${chat_path}.cursors" 2>/dev/null) || true
                        cursor=$((${cursor:-0} + 0))
                    fi
                fi

                # Unread if total messages > cursor position + 1
                # (cursor is 0-indexed: cursor=0 means message 0 has been read)
                if (( total > cursor + 1 )); then
                    local chat_name
                    chat_name=$(basename "$chat_path")
                    local n_unread=$((total - cursor - 1))
                    CHAT_UNREAD_COUNT=$((CHAT_UNREAD_COUNT + n_unread))
                    if [[ -n "$unread_chats" ]]; then
                        unread_chats="${unread_chats}, ${chat_name}"
                    else
                        unread_chats="$chat_name"
                    fi
                fi
                ;;
        esac
    done < "$CONTROL_REGISTRY"

    if [[ $CHAT_UNREAD_COUNT -gt 0 ]]; then
        CHAT_UNREAD_SUMMARY="${CHAT_UNREAD_COUNT} unread in ${unread_chats}"
    fi

    [[ $has_chat -eq 0 ]] && return 2
    [[ $CHAT_UNREAD_COUNT -eq 0 ]] && return 1
    return 0
}

# should_inject_notify — decide whether to inject /nbs-notify.
# Combines bus and chat checks, applies cooldown logic.
# Critical priority bypasses cooldown.
# Sets NOTIFY_MESSAGE with summary text (capped at 200 chars).
# Returns: 0 = should inject, 1 = should not.
should_inject_notify() {
    NOTIFY_MESSAGE=""

    # Startup grace period: do not inject notifications until the agent has
    # had time to process any manually-sent role prompts. This prevents the
    # sidecar from racing ahead of the user's initial prompt.
    local now
    now=$(date +%s)
    if [[ $SIDECAR_START_TIME -gt 0 ]]; then
        local grace_elapsed=$((now - SIDECAR_START_TIME))
        if [[ $grace_elapsed -lt $STARTUP_GRACE ]]; then
            return 1
        fi
    fi

    local bus_rc=0
    check_bus_events || bus_rc=$?

    local chat_rc=0
    check_chat_unread || chat_rc=$?

    # Nothing pending
    if [[ $bus_rc -ne 0 && $chat_rc -ne 0 ]]; then
        return 1
    fi

    # Apply cooldown (critical bypasses)
    now=$(date +%s)
    local elapsed=$((now - LAST_NOTIFY_TIME))

    if [[ "$BUS_MAX_PRIORITY" != "critical" && $elapsed -lt $NOTIFY_COOLDOWN ]]; then
        return 1
    fi

    # Build summary message
    local parts=""
    if [[ -n "$BUS_EVENT_SUMMARY" ]]; then
        parts="$BUS_EVENT_SUMMARY"
    fi
    if [[ -n "$CHAT_UNREAD_SUMMARY" ]]; then
        if [[ -n "$parts" ]]; then
            parts="${parts}. ${CHAT_UNREAD_SUMMARY}"
        else
            parts="$CHAT_UNREAD_SUMMARY"
        fi
    fi

    # Cap at 200 chars for tmux safety
    if [[ ${#parts} -gt 200 ]]; then
        parts="${parts:0:197}..."
    fi

    NOTIFY_MESSAGE="$parts"
    LAST_NOTIFY_TIME=$now
    return 0
}

# --- Prompt detection ---

is_prompt_visible() {
    local content="$1"
    echo "$content" | tail -3 | grep -qF '❯'
}

# --- Idle detection sidecar (tmux mode) ---
# Monitors the current tmux pane. Checks bus/chat every BUS_CHECK_INTERVAL
# seconds and injects /nbs-notify when events or messages are pending.
# Falls back to /nbs-poll as a safety net after POLL_INTERVAL seconds.

poll_sidecar_tmux() {
    local pane_id="$1"

    local idle_seconds=0
    local bus_check_counter=0
    local last_content_hash=""

    # Seed registry with existing resources
    seed_registry

    # Inject initial prompt — either custom (NBS_INITIAL_PROMPT) or default (handle + skill)
    # Wait for Claude's prompt to appear, then send the initial prompt
    local init_prompt
    if [[ -n "$INITIAL_PROMPT" ]]; then
        init_prompt="$INITIAL_PROMPT"
    else
        init_prompt="Your NBS handle is '${SIDECAR_HANDLE}'. Load /nbs-teams-chat. Use this handle for all nbs-chat send commands."
    fi
    local init_wait=0
    while [[ $init_wait -lt 60 ]]; do
        sleep 2
        local init_content
        init_content=$(tmux capture-pane -t "$pane_id" -p -S -5 2>/dev/null) || true
        if echo "$init_content" | tail -3 | grep -qE '❯|>\s*$'; then
            tmux send-keys -t "$pane_id" -l "$init_prompt" || true
            sleep 0.3
            tmux send-keys -t "$pane_id" Enter || true
            sleep 5
            SIDECAR_START_TIME=$(date +%s)
            last_content_hash=""
            break
        fi
        init_wait=$((init_wait + 2))
    done

    while true; do
        sleep 1

        # Check control inbox for new registration commands
        check_control_inbox

        # Check pane still exists
        if ! tmux list-panes -t "$pane_id" &>/dev/null; then
            break
        fi

        # Capture current pane content
        local content
        content=$(tmux capture-pane -t "$pane_id" -p -S -5 2>/dev/null) || continue

        # Hash the content to detect changes
        local current_hash
        current_hash=$(echo "$content" | sha256sum | cut -d' ' -f1)

        if [[ "$current_hash" != "$last_content_hash" ]]; then
            idle_seconds=0
            bus_check_counter=0
            last_content_hash="$current_hash"

            # Check for plan mode immediately on content change
            # Plan mode blocks the worker — resolve it without waiting for idle
            if detect_plan_mode "$content"; then
                sleep 1
                tmux send-keys -t "$pane_id" '2' || true
                sleep 0.5
                tmux send-keys -t "$pane_id" Enter || true
                idle_seconds=0
                last_content_hash=""
                sleep 5
            fi

            # Check for AskUserQuestion modal — auto-select option 1
            if detect_ask_modal "$content"; then
                sleep 1
                tmux send-keys -t "$pane_id" '1' || true
                sleep 0.5
                tmux send-keys -t "$pane_id" Enter || true
                idle_seconds=0
                last_content_hash=""
                sleep 5
            fi
            continue
        fi

        # Also check for plan mode when content is stable (already idle)
        if detect_plan_mode "$content"; then
            tmux send-keys -t "$pane_id" '2' || true
            sleep 0.5
            tmux send-keys -t "$pane_id" Enter || true
            idle_seconds=0
            last_content_hash=""
            sleep 5
            continue
        fi

        # Check for AskUserQuestion modal when content is stable
        if detect_ask_modal "$content"; then
            tmux send-keys -t "$pane_id" '1' || true
            sleep 0.5
            tmux send-keys -t "$pane_id" Enter || true
            idle_seconds=0
            last_content_hash=""
            sleep 5
            continue
        fi

        idle_seconds=$((idle_seconds + 1))
        bus_check_counter=$((bus_check_counter + 1))

        # --- Track 1: Bus-aware fast check ---
        # Check bus and chat every BUS_CHECK_INTERVAL seconds.
        # Only inject /nbs-notify if something is actually pending.
        if [[ $bus_check_counter -ge $BUS_CHECK_INTERVAL ]]; then
            bus_check_counter=0

            if is_prompt_visible "$content"; then
                # Skip injection if Claude is context-stressed (compacting, too long, etc.)
                if detect_context_stress "$content"; then
                    idle_seconds=0
                    last_content_hash=""
                    sleep 30
                    continue
                fi
                if should_inject_notify; then
                    # Check if we've exceeded the failure threshold — switch to recovery mode
                    if [[ $NOTIFY_FAIL_COUNT -ge $NOTIFY_FAIL_THRESHOLD ]]; then
                        local recovery_prompt
                        recovery_prompt=$(build_recovery_prompt)
                        tmux send-keys -t "$pane_id" -l "$recovery_prompt" || true
                        sleep 0.3
                        tmux send-keys -t "$pane_id" Enter || true

                        # Wait for recovery to be processed
                        sleep 5
                        local recovery_content
                        recovery_content=$(tmux capture-pane -t "$pane_id" -p -S -5 2>/dev/null) || true
                        if ! detect_skill_failure "$recovery_content"; then
                            NOTIFY_FAIL_COUNT=0
                        fi

                        idle_seconds=0
                        last_content_hash=""
                        sleep 15
                        continue
                    fi

                    tmux send-keys -t "$pane_id" -l "/nbs-notify ${NOTIFY_MESSAGE}" || true
                    sleep 0.3
                    tmux send-keys -t "$pane_id" Enter || true

                    # Verify injection was consumed: prompt should disappear
                    sleep 2
                    local verify_content
                    verify_content=$(tmux capture-pane -t "$pane_id" -p -S -5 2>/dev/null) || true
                    if is_prompt_visible "$verify_content"; then
                        # Check if this was a skill failure
                        if detect_skill_failure "$verify_content"; then
                            NOTIFY_FAIL_COUNT=$((NOTIFY_FAIL_COUNT + 1))
                        else
                            # Prompt still visible but not a skill failure — retry once
                            tmux send-keys -t "$pane_id" Enter || true
                            sleep 1
                        fi
                    else
                        # Injection consumed successfully — reset failure counter
                        NOTIFY_FAIL_COUNT=0
                    fi

                    idle_seconds=0
                    last_content_hash=""
                    sleep 8
                    continue
                fi
            fi
        fi

        # --- Track 2: Safety net poll ---
        # Full /nbs-poll after extended idle. Catches bus failures,
        # unregistered resources, anything the fast check missed.
        if [[ $idle_seconds -ge $POLL_INTERVAL ]]; then
            if is_prompt_visible "$content"; then
                # Skip injection if Claude is context-stressed
                if detect_context_stress "$content"; then
                    idle_seconds=0
                    last_content_hash=""
                    sleep 30
                    continue
                fi
                tmux send-keys -t "$pane_id" -l '/nbs-poll' || true
                sleep 0.3
                tmux send-keys -t "$pane_id" Enter || true

                idle_seconds=0
                last_content_hash=""
                sleep 10
            else
                idle_seconds=0
            fi
        fi
    done
}

# --- Idle detection sidecar (pty-session mode) ---

poll_sidecar_pty() {
    local pty="$1"
    local session="$2"

    local idle_seconds=0
    local bus_check_counter=0
    local last_content_hash=""

    # Seed registry with existing resources
    seed_registry

    # Inject initial prompt — either custom (NBS_INITIAL_PROMPT) or default (handle + skill)
    # Wait for Claude's prompt to appear, then send the initial prompt
    local init_prompt
    if [[ -n "$INITIAL_PROMPT" ]]; then
        init_prompt="$INITIAL_PROMPT"
    else
        init_prompt="Your NBS handle is '${SIDECAR_HANDLE}'. Load /nbs-teams-chat. Use this handle for all nbs-chat send commands."
    fi
    local init_wait=0
    while [[ $init_wait -lt 60 ]]; do
        sleep 2
        local init_content
        init_content=$("$pty" read "$session" --scrollback=5 2>/dev/null) || true
        if echo "$init_content" | tail -3 | grep -qE '❯|>\s*$'; then
            "$pty" send "$session" "$init_prompt" || true
            sleep 0.5
            "$pty" send "$session" '' || true
            sleep 5
            SIDECAR_START_TIME=$(date +%s)
            last_content_hash=""
            break
        fi
        init_wait=$((init_wait + 2))
    done

    while true; do
        sleep 1

        # Check control inbox for new registration commands
        check_control_inbox

        if ! "$pty" list 2>/dev/null | grep -qxF "$session"; then
            break
        fi

        local content
        content=$("$pty" read "$session" --scrollback=5 2>/dev/null) || continue

        local current_hash
        current_hash=$(echo "$content" | sha256sum | cut -d' ' -f1)

        if [[ "$current_hash" != "$last_content_hash" ]]; then
            idle_seconds=0
            bus_check_counter=0
            last_content_hash="$current_hash"

            # Check for plan mode immediately on content change
            if detect_plan_mode "$content"; then
                sleep 1
                "$pty" send "$session" --no-enter '2' || true
                sleep 0.5
                "$pty" send "$session" '' || true
                idle_seconds=0
                last_content_hash=""
                sleep 5
            fi

            # Check for AskUserQuestion modal — auto-select option 1
            if detect_ask_modal "$content"; then
                sleep 1
                "$pty" send "$session" --no-enter '1' || true
                sleep 0.5
                "$pty" send "$session" '' || true
                idle_seconds=0
                last_content_hash=""
                sleep 5
            fi
            continue
        fi

        # Check for plan mode when content is stable
        if detect_plan_mode "$content"; then
            "$pty" send "$session" --no-enter '2' || true
            sleep 0.5
            "$pty" send "$session" '' || true
            idle_seconds=0
            last_content_hash=""
            sleep 5
            continue
        fi

        # Check for AskUserQuestion modal when content is stable
        if detect_ask_modal "$content"; then
            "$pty" send "$session" --no-enter '1' || true
            sleep 0.5
            "$pty" send "$session" '' || true
            idle_seconds=0
            last_content_hash=""
            sleep 5
            continue
        fi

        idle_seconds=$((idle_seconds + 1))
        bus_check_counter=$((bus_check_counter + 1))

        # --- Track 1: Bus-aware fast check ---
        if [[ $bus_check_counter -ge $BUS_CHECK_INTERVAL ]]; then
            bus_check_counter=0

            if is_prompt_visible "$content"; then
                # Skip injection if Claude is context-stressed (compacting, too long, etc.)
                if detect_context_stress "$content"; then
                    idle_seconds=0
                    last_content_hash=""
                    sleep 30
                    continue
                fi
                if should_inject_notify; then
                    # Check if we've exceeded the failure threshold — switch to recovery mode
                    if [[ $NOTIFY_FAIL_COUNT -ge $NOTIFY_FAIL_THRESHOLD ]]; then
                        local recovery_prompt
                        recovery_prompt=$(build_recovery_prompt)
                        "$pty" send "$session" "$recovery_prompt" || true
                        sleep 0.5
                        "$pty" send "$session" '' || true

                        # Wait for recovery to be processed
                        sleep 5
                        local recovery_content
                        recovery_content=$("$pty" read "$session" --scrollback=5 2>/dev/null) || true
                        if ! detect_skill_failure "$recovery_content"; then
                            NOTIFY_FAIL_COUNT=0
                        fi

                        idle_seconds=0
                        last_content_hash=""
                        sleep 15
                        continue
                    fi

                    "$pty" send "$session" "/nbs-notify ${NOTIFY_MESSAGE}" || true
                    sleep 0.5
                    "$pty" send "$session" '' || true

                    # Verify injection was consumed: prompt should disappear
                    sleep 2
                    local verify_content
                    verify_content=$("$pty" read "$session" --scrollback=5 2>/dev/null) || true
                    if is_prompt_visible "$verify_content"; then
                        # Check if this was a skill failure
                        if detect_skill_failure "$verify_content"; then
                            NOTIFY_FAIL_COUNT=$((NOTIFY_FAIL_COUNT + 1))
                        else
                            # Prompt still visible but not a skill failure — retry once
                            "$pty" send "$session" '' || true
                            sleep 1
                        fi
                    else
                        # Injection consumed successfully — reset failure counter
                        NOTIFY_FAIL_COUNT=0
                    fi

                    idle_seconds=0
                    last_content_hash=""
                    sleep 8
                    continue
                fi
            fi
        fi

        # --- Track 2: Safety net poll ---
        if [[ $idle_seconds -ge $POLL_INTERVAL ]]; then
            if is_prompt_visible "$content"; then
                # Skip injection if Claude is context-stressed
                if detect_context_stress "$content"; then
                    idle_seconds=0
                    last_content_hash=""
                    sleep 30
                    continue
                fi
                "$pty" send "$session" '/nbs-poll' || true
                sleep 0.5
                "$pty" send "$session" '' || true

                idle_seconds=0
                last_content_hash=""
                sleep 10
            else
                idle_seconds=0
            fi
        fi
    done
}

# --- Main ---

# Build claude command with args (intercept --root= for sidecar)
CLAUDE_ARGS=("claude")
for arg in "$@"; do
    case "$arg" in
        --root=*)
            NBS_ROOT="${arg#--root=}"
            ;;
        --remote-host=*)
            NBS_REMOTE_HOST="${arg#--remote-host=}"
            ;;
        --remote-ssh-opts=*)
            NBS_REMOTE_SSH_OPTS="${arg#--remote-ssh-opts=}"
            ;;
        *)
            CLAUDE_ARGS+=("$arg")
            ;;
    esac
done

# Re-resolve NBS_ROOT to absolute if overridden by --root=
NBS_ROOT="$(cd "$NBS_ROOT" 2>/dev/null && pwd)" || {
    echo "Error: NBS_ROOT directory does not exist: ${NBS_ROOT}" >&2
    exit 1
}

# Assert NBS_ROOT exists as a directory
if [[ ! -d "$NBS_ROOT" ]]; then
    echo "Error: NBS_ROOT is not a directory: $NBS_ROOT" >&2
    exit 1
fi

# Re-set control paths after potential --root= override
CONTROL_INBOX="${NBS_ROOT}/.nbs/control-inbox-${SIDECAR_HANDLE}"
CONTROL_REGISTRY="${NBS_ROOT}/.nbs/control-registry-${SIDECAR_HANDLE}"
NBS_LOG_FILE="${NBS_ROOT}/.nbs/nbs-claude-$$.log"

echo "Starting Claude Code with NBS bus-aware polling..."
echo "  Bus check interval: ${BUS_CHECK_INTERVAL}s"
echo "  Notify cooldown: ${NOTIFY_COOLDOWN}s"
echo "  Safety net poll: ${POLL_INTERVAL}s idle"
echo "  Handle: ${SIDECAR_HANDLE}"
echo "  Startup grace: ${STARTUP_GRACE}s"
echo "  Self-heal threshold: ${NOTIFY_FAIL_THRESHOLD} failures"
echo "  Root: ${NBS_ROOT}"
if [[ -n "$INITIAL_PROMPT" ]]; then
    echo "  Initial prompt: custom (NBS_INITIAL_PROMPT)"
fi
if [[ -n "$NBS_REMOTE_HOST" ]]; then
    echo "  Remote: ${NBS_REMOTE_HOST}"
fi
if [[ "$POLL_DISABLE" == "1" ]]; then
    echo "  Polling: DISABLED"
fi

if [[ -n "${TMUX:-}" ]]; then
    # --- Already inside tmux ---
    MODE="tmux"

    # Get current pane ID before launching claude
    PANE_ID=$(tmux display-message -p '#{pane_id}')
    echo "  Mode: tmux (pane $PANE_ID)"
    echo ""

    # Start sidecar monitoring this pane
    if [[ "$POLL_DISABLE" != "1" ]]; then
        poll_sidecar_tmux "$PANE_ID" &
        SIDECAR_PID=$!
    fi

    # Run claude in foreground — replaces this process's foreground
    # but the sidecar is already running in background
    "${CLAUDE_ARGS[@]}"

    # Claude exited — cleanup runs via trap
else
    # --- Not inside tmux ---
    MODE="pty"
    SESSION_NAME="nbs-claude-$$"

    echo "  Mode: pty-session ($SESSION_NAME)"
    echo ""

    # Build command string for pty-session (skip --root= which is sidecar-only)
    # EVAL CONTRACT: CLAUDE_CMD is a single string passed to pty-session, which
    # evaluates it via the shell. Each argument is individually shell-quoted via
    # printf '%q' to prevent injection. The only inputs are our own argv elements
    # after filtering out --root=, --remote-host=, --remote-ssh-opts= prefixes.
    # No environment variables or external data are interpolated unquoted.
    CLAUDE_CMD="claude"
    if [[ $# -gt 0 ]]; then
        CLAUDE_CMD_ARGS=""
        for arg in "$@"; do
            case "$arg" in --root=*|--remote-host=*|--remote-ssh-opts=*) continue ;; esac
            if [[ -z "$CLAUDE_CMD_ARGS" ]]; then
                CLAUDE_CMD_ARGS="$(printf '%q' "$arg")"
            else
                CLAUDE_CMD_ARGS="$CLAUDE_CMD_ARGS $(printf '%q' "$arg")"
            fi
        done
        CLAUDE_CMD="claude $CLAUDE_CMD_ARGS"
    fi

    # Create pty-session running claude
    # NOTE: eval is required here because CLAUDE_CMD is a single string
    # containing shell-quoted arguments built by printf '%q' above.
    # This is safe because the string is constructed entirely from our own
    # argv processing — no external input reaches it unquoted.
    if ! "$PTY_SESSION" create "$SESSION_NAME" "$CLAUDE_CMD"; then
        echo "Error: Failed to create pty-session" >&2
        exit 1
    fi

    # Start sidecar if polling enabled
    if [[ "$POLL_DISABLE" != "1" ]]; then
        poll_sidecar_pty "$PTY_SESSION" "$SESSION_NAME" &
        SIDECAR_PID=$!
    fi

    # Attach to the session
    # NOTE: pty-session creates tmux sessions with a "pty_" prefix convention.
    # Verify the session exists before attaching.
    TMUX_SESSION="pty_${SESSION_NAME}"
    if ! tmux has-session -t "$TMUX_SESSION" 2>/dev/null; then
        echo "Error: tmux session '$TMUX_SESSION' does not exist after pty-session create" >&2
        exit 1
    fi
    tmux attach-session -t "$TMUX_SESSION"
fi

# When user exits, cleanup runs via trap
