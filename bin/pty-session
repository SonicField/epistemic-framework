#!/bin/bash
# pty-session: Manage interactive terminal sessions via tmux
#
# This script enables Claude (or any automation) to interact with
# long-running interactive processes across multiple invocations.
#
# Sessions are prefixed with 'pty_' to avoid collision with user sessions.
#
# Usage:
#   pty-session create <name> <command>   Create session running command
#   pty-session send <name> <text>        Send keystrokes (adds Enter by default)
#   pty-session read <name>               Read session output (live, cache, or log)
#   pty-session wait <name> <pattern>     Poll until pattern appears (default 60s)
#   pty-session kill <name>               Terminate session (screen cached)
#   pty-session list                      Show active and killed pty-session sessions
#   pty-session help                      Show this help
#
# Options:
#   --no-enter     With 'send': don't append Enter after text
#   --timeout=N    With 'wait' or 'read --wait': timeout in seconds
#   --scrollback=N With 'read': lines of scrollback to capture (default 100)
#   --last=N       Alias for --scrollback=N
#   --wait         With 'read': block until session exits, then read cache
#
# Examples:
#   pty-session create myrepl 'python3'
#   pty-session send myrepl 'print("hello")'
#   pty-session read myrepl
#   pty-session wait myrepl '>>>'
#   pty-session kill myrepl
#
# Exit codes:
#   0 - Success
#   1 - General error
#   2 - Session not found
#   3 - Timeout (for wait command)
#   4 - Invalid arguments

set -uo pipefail

PREFIX="pty_"
CACHE_DIR="${HOME}/.pty-session/cache"
LOG_DIR="${HOME}/.pty-session/logs"

# Tool reminder header — shown on pty-session read/send output unless
# suppressed by NBS_PTY_QUIET=1 (set by higher-level tools like
# nbs-remote-build, nbs-remote-edit-pty, nbs-remote-diff, etc.)
show_tool_header() {
    if [[ "${NBS_PTY_QUIET:-0}" == "1" ]]; then
        return
    fi
    echo "┌─ pty-session: consider higher-level tools ──────────────────────┐" >&2
    echo "│ Edit files:  nbs-remote-edit-pty pull/push/diff <ses> <path>    │" >&2
    echo "│ Build:       nbs-remote-build <ses> '<cmd>' --chat=... --handle │" >&2
    echo "│ Git diff:    nbs-remote-diff <ses> --cwd=<dir> --commit=<ref>   │" >&2
    echo "│ Git status:  nbs-remote-status <ses> --cwd=<dir>                │" >&2
    echo "│ Lock:        pty-session-lock acquire/release <ses> <handle>     │" >&2
    echo "│ Suppress:    export NBS_PTY_QUIET=1                             │" >&2
    echo "└─────────────────────────────────────────────────────────────────┘" >&2
}

# Output capture has two layers:
#
#   Log  (persistent) — tmux pipe-pane streams all output to LOG_DIR/<name>.log
#                        from the moment of creation. Survives any exit.
#
#   Cache (snapshot)  — tmux capture-pane grabs the last 100 screen lines into
#                        CACHE_DIR/<name>.output at kill time. Consumed on read.
#
# `read` resolves output as: live pane → cache → persistent log.

usage() {
    grep '^#' "$0" | grep -v '!/bin/bash' | cut -c3-
}

session_name() {
    echo "${PREFIX}$1"
}

session_exists() {
    local name
    name=$(session_name "$1")
    tmux has-session -t "$name" 2>/dev/null
}

cache_exists() {
    local name="$1"
    [[ -f "${CACHE_DIR}/${name}.output" ]]
}

cache_session() {
    local name="$1"
    local session
    session=$(session_name "$name")

    # Create cache directory if it doesn't exist
    mkdir -p "$CACHE_DIR" 2>/dev/null || return 1

    # Capture pane content
    tmux capture-pane -t "$session" -p -S -100 > "${CACHE_DIR}/${name}.output" 2>/dev/null || return 1

    # Save timestamp
    date +%s > "${CACHE_DIR}/${name}.timestamp" 2>/dev/null || return 1

    return 0
}

read_cache() {
    local name="$1"

    if ! cache_exists "$name"; then
        return 1
    fi

    # Output the cached content
    cat "${CACHE_DIR}/${name}.output"

    # Delete cache files after reading
    rm -f "${CACHE_DIR}/${name}.output" "${CACHE_DIR}/${name}.timestamp" 2>/dev/null

    return 0
}

cmd_create() {
    local name="${1:-}"
    shift 2>/dev/null || true
    local command="$*"

    if [[ -z "$name" ]] || [[ -z "$command" ]]; then
        echo "Error: create requires <name> and <command>" >&2
        echo "Usage: pty-session create <name> <command>" >&2
        return 4
    fi

    local session
    session=$(session_name "$name")

    if tmux has-session -t "$session" 2>/dev/null; then
        echo "Error: Session '$name' already exists" >&2
        return 1
    fi

    tmux new-session -d -s "$session" "$command"
    local rc=$?

    if [[ $rc -eq 0 ]]; then
        # Persistent logging — stream all output to a log file
        mkdir -p "$LOG_DIR" 2>/dev/null
        local log_file="${LOG_DIR}/${name}.log"
        tmux pipe-pane -t "$session" -o "cat >> '${log_file}'"
        echo "Created session: $name"
    fi
    return $rc
}

cmd_send() {
    local name="${1:-}"
    local no_enter=false
    shift 2>/dev/null || true

    show_tool_header

    # Check for --no-enter flag
    if [[ "${1:-}" == "--no-enter" ]]; then
        no_enter=true
        shift
    fi

    local text="$*"

    if [[ -z "$name" ]]; then
        echo "Error: send requires <name> and <text>" >&2
        return 4
    fi

    local session
    session=$(session_name "$name")

    if ! tmux has-session -t "$session" 2>/dev/null; then
        echo "Error: Session '$name' not found" >&2
        return 2
    fi

    # Send the text
    tmux send-keys -t "$session" "$text"

    # Send Enter unless --no-enter specified
    if [[ "$no_enter" == false ]]; then
        # Small delay then Enter for reliable submission
        sleep 0.1
        tmux send-keys -t "$session" Enter
    fi

    return 0
}

cmd_read() {
    local name="${1:-}"
    local scrollback=100
    local wait_mode=false
    local timeout=300

    show_tool_header

    # Parse options
    shift 2>/dev/null || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --scrollback=*|--last=*)
                scrollback="${1#*=}"
                shift
                ;;
            --wait)
                wait_mode=true
                shift
                ;;
            --timeout=*)
                timeout="${1#--timeout=}"
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$name" ]]; then
        echo "Error: read requires <name>" >&2
        return 4
    fi

    local session
    session=$(session_name "$name")

    # Wait mode: poll until session exits, then read cache
    if [[ "$wait_mode" == true ]]; then
        local elapsed=0
        local interval=0.5

        while tmux has-session -t "$session" 2>/dev/null; do
            if (( $(echo "$elapsed >= $timeout" | bc -l) )); then
                echo "Error: Timeout after ${timeout}s waiting for session to exit" >&2
                return 3
            fi
            sleep "$interval"
            elapsed=$(echo "$elapsed + $interval" | bc -l)
        done

        # Session has exited, read from cache
        if read_cache "$name"; then
            return 0
        fi

        # Cache miss — try persistent log file
        local log_file="${LOG_DIR}/${name}.log"
        if [[ -f "$log_file" ]]; then
            echo "(from persistent log)" >&2
            sed 's/\x1b\[[0-9;]*[a-zA-Z]//g; s/\x1b\][^\x07]*\x07//g; s/\x1b[()][0-9A-B]//g' "$log_file"
            return 0
        fi

        echo "Error: Session exited but no output found (no cache or log)" >&2
        return 2
    fi

    # Non-wait mode: try live session first, then cache
    if tmux has-session -t "$session" 2>/dev/null; then
        # Capture pane with scrollback
        tmux capture-pane -t "$session" -p -S "-$scrollback"
        return 0
    fi

    # Session not running, try cache
    if read_cache "$name"; then
        return 0
    fi

    # Cache miss — try persistent log file
    local log_file="${LOG_DIR}/${name}.log"
    if [[ -f "$log_file" ]]; then
        echo "(from persistent log)" >&2
        # Strip ANSI escape codes for readability
        sed 's/\x1b\[[0-9;]*[a-zA-Z]//g; s/\x1b\][^\x07]*\x07//g; s/\x1b[()][0-9A-B]//g' "$log_file"
        return 0
    fi

    echo "Error: Session '$name' not found" >&2
    return 2
}

cmd_wait() {
    local name="${1:-}"
    local pattern="${2:-}"
    local timeout=60

    # Check for --timeout option
    if [[ "${3:-}" == --timeout=* ]]; then
        timeout="${3#--timeout=}"
    fi

    if [[ -z "$name" ]] || [[ -z "$pattern" ]]; then
        echo "Error: wait requires <name> and <pattern>" >&2
        return 4
    fi

    local session
    session=$(session_name "$name")

    if ! tmux has-session -t "$session" 2>/dev/null; then
        echo "Error: Session '$name' not found" >&2
        return 2
    fi

    local elapsed=0
    local interval=0.5

    while (( $(echo "$elapsed < $timeout" | bc -l) )); do
        local content
        content=$(tmux capture-pane -t "$session" -p -S -100)

        if echo "$content" | grep -q "$pattern"; then
            echo "Pattern found after ${elapsed}s"
            return 0
        fi

        sleep "$interval"
        elapsed=$(echo "$elapsed + $interval" | bc -l)
    done

    echo "Timeout after ${timeout}s waiting for pattern: $pattern" >&2
    return 3
}

cmd_kill() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        echo "Error: kill requires <name>" >&2
        return 4
    fi

    local session
    session=$(session_name "$name")

    if ! tmux has-session -t "$session" 2>/dev/null; then
        echo "Error: Session '$name' not found" >&2
        return 2
    fi

    # Cache session output before killing
    cache_session "$name" || echo "Warning: Failed to cache session output" >&2

    tmux kill-session -t "$session"
    local rc=$?

    if [[ $rc -eq 0 ]]; then
        echo "Killed session: $name"
    fi
    return $rc
}

cmd_list() {
    echo "Active pty-session sessions:"

    local has_sessions=false

    # List running sessions
    if tmux list-sessions -F '#{session_name}' 2>/dev/null | grep -q "^${PREFIX}"; then
        tmux list-sessions -F '#{session_name}' 2>/dev/null | grep "^${PREFIX}" | while read -r session; do
            local name="${session#${PREFIX}}"
            printf "  %-20s running\n" "$name"
            has_sessions=true
        done
    fi

    # List killed sessions (from cache)
    local seen_names=()
    if [[ -d "$CACHE_DIR" ]]; then
        shopt -s nullglob
        for cache_file in "${CACHE_DIR}"/*.output; do
            if [[ -f "$cache_file" ]]; then
                local name
                name=$(basename "$cache_file" .output)
                printf "  %-20s killed (cached)\n" "$name"
                seen_names+=("$name")
                has_sessions=true
            fi
        done
        shopt -u nullglob
    fi

    # List sessions with logs but no cache (exited naturally)
    if [[ -d "$LOG_DIR" ]]; then
        shopt -s nullglob
        for log_file in "${LOG_DIR}"/*.log; do
            if [[ -f "$log_file" ]]; then
                local name
                name=$(basename "$log_file" .log)
                # Skip if already listed from cache or still running
                local already_seen=false
                for seen in "${seen_names[@]+"${seen_names[@]}"}"; do
                    if [[ "$seen" == "$name" ]]; then
                        already_seen=true
                        break
                    fi
                done
                if [[ "$already_seen" == false ]] && ! tmux has-session -t "${PREFIX}${name}" 2>/dev/null; then
                    printf "  %-20s exited (log available)\n" "$name"
                    has_sessions=true
                fi
            fi
        done
        shopt -u nullglob
    fi

    if [[ "$has_sessions" == false ]]; then
        echo "  (none)"
    fi
}

# Main dispatch
case "${1:-}" in
    create)
        shift
        cmd_create "$@"
        ;;
    send)
        shift
        cmd_send "$@"
        ;;
    read)
        shift
        cmd_read "$@"
        ;;
    wait)
        shift
        cmd_wait "$@"
        ;;
    kill)
        shift
        cmd_kill "$@"
        ;;
    list)
        cmd_list
        ;;
    help|--help|-h|"")
        usage
        ;;
    *)
        echo "Unknown command: $1" >&2
        echo "Run 'pty-session help' for usage" >&2
        exit 4
        ;;
esac
