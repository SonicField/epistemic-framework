#!/bin/bash
# pty-session-lock: Exclusive session reservation for pty-sessions
#
# Prevents two agents from sending commands to the same pty-session
# simultaneously, which corrupts output and causes failed builds.
#
# Uses flock-based locking with a lock file per session. The lock is
# advisory — agents must use this tool voluntarily for it to work.
#
# Usage:
#   pty-session-lock acquire <session> <handle> [--timeout=N]
#   pty-session-lock release <session> <handle>
#   pty-session-lock check <session>
#   pty-session-lock help
#
# Arguments:
#   <session>   Name of the pty-session (e.g. devgpu-p3b)
#   <handle>    Your agent handle (e.g. claude, generalist)
#
# Options:
#   --timeout=N   Seconds to wait for lock acquisition (default: 0, fail immediately)
#   --chat=FILE   Post lock status changes to this chat file
#   --chat-handle=NAME   Chat handle for status posts
#
# Examples:
#   # Acquire exclusive access
#   pty-session-lock acquire devgpu-p3b claude
#   pty-session send devgpu-p3b 'make -j8'
#   nbs-remote-build devgpu-p3b 'make -j8' ...
#   pty-session-lock release devgpu-p3b claude
#
#   # Check who holds the lock
#   pty-session-lock check devgpu-p3b
#   # Output: devgpu-p3b: locked by claude (since 2026-02-20T15:30:00Z)
#   # or:    devgpu-p3b: unlocked
#
#   # Wait up to 60s for lock to become available
#   pty-session-lock acquire devgpu-p3b generalist --timeout=60
#
# Exit codes:
#   0 - Success (acquired, released, or unlocked)
#   1 - General error
#   2 - Lock held by another agent (acquire failed)
#   3 - Timeout waiting for lock
#   4 - Invalid arguments
#   5 - Release failed (you don't own the lock)

set -euo pipefail

LOCK_DIR="${NBS_PTY_LOCK_DIR:-.nbs/pty-locks}"
CHAT_FILE=""
CHAT_HANDLE=""

usage() {
    grep '^#' "$0" | grep -v '!/bin/bash' | cut -c3-
}

lock_file() {
    echo "${LOCK_DIR}/${1}.lock"
}

info_file() {
    echo "${LOCK_DIR}/${1}.info"
}

cmd_acquire() {
    local session="${1:-}"
    local handle="${2:-}"
    local timeout=0

    # Parse remaining args for options
    shift 2 2>/dev/null || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --timeout=*) timeout="${1#--timeout=}"; shift ;;
            --chat=*)    CHAT_FILE="${1#--chat=}"; shift ;;
            --chat-handle=*) CHAT_HANDLE="${1#--chat-handle=}"; shift ;;
            *) shift ;;
        esac
    done

    if [[ -z "$session" ]] || [[ -z "$handle" ]]; then
        echo "Error: acquire requires <session> and <handle>" >&2
        return 4
    fi

    mkdir -p "$LOCK_DIR"

    local lf
    lf=$(lock_file "$session")
    local inf
    inf=$(info_file "$session")

    # Check if already locked by someone else
    if [[ -f "$inf" ]]; then
        local current_holder
        current_holder=$(head -1 "$inf" 2>/dev/null || true)
        if [[ "$current_holder" == "$handle" ]]; then
            # Already held by us — refresh timestamp
            echo "${handle}" > "$inf"
            echo "$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$inf"
            echo "${session}: lock refreshed by ${handle}"
            return 0
        fi
    fi

    # Try to acquire with flock
    local elapsed=0
    while true; do
        # Try non-blocking first
        if (
            flock -n 200 || exit 1
            # Check info file inside lock to prevent race
            if [[ -f "$inf" ]]; then
                local holder
                holder=$(head -1 "$inf" 2>/dev/null || true)
                if [[ -n "$holder" ]] && [[ "$holder" != "$handle" ]]; then
                    exit 1
                fi
            fi
            # Write lock info
            echo "${handle}" > "$inf"
            echo "$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$inf"
            exit 0
        ) 200>"$lf" 2>/dev/null; then
            echo "${session}: locked by ${handle}"

            # Post to chat if configured
            if [[ -n "$CHAT_FILE" ]] && [[ -n "$CHAT_HANDLE" ]]; then
                local NBS_CHAT="${HOME}/.nbs/bin/nbs-chat"
                "$NBS_CHAT" send "$CHAT_FILE" "$CHAT_HANDLE" \
                    "@team — I have acquired exclusive access to pty-session ${session}. No one else should send commands to it until I release." \
                    2>/dev/null || true
            fi

            return 0
        fi

        # Lock not available
        if (( elapsed >= timeout )); then
            if (( timeout > 0 )); then
                echo "Error: Timed out waiting for lock on ${session} (${timeout}s)" >&2
                return 3
            else
                local holder="unknown"
                if [[ -f "$inf" ]]; then
                    holder=$(head -1 "$inf" 2>/dev/null || echo "unknown")
                fi
                echo "Error: ${session} is locked by ${holder}" >&2
                return 2
            fi
        fi

        sleep 2
        elapsed=$((elapsed + 2))
    done
}

cmd_release() {
    local session="${1:-}"
    local handle="${2:-}"

    # Parse remaining args for options
    shift 2 2>/dev/null || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --chat=*)    CHAT_FILE="${1#--chat=}"; shift ;;
            --chat-handle=*) CHAT_HANDLE="${1#--chat-handle=}"; shift ;;
            *) shift ;;
        esac
    done

    if [[ -z "$session" ]] || [[ -z "$handle" ]]; then
        echo "Error: release requires <session> and <handle>" >&2
        return 4
    fi

    local inf
    inf=$(info_file "$session")

    if [[ ! -f "$inf" ]]; then
        echo "${session}: already unlocked"
        return 0
    fi

    local current_holder
    current_holder=$(head -1 "$inf" 2>/dev/null || true)

    if [[ "$current_holder" != "$handle" ]]; then
        echo "Error: ${session} is locked by ${current_holder}, not ${handle}" >&2
        return 5
    fi

    rm -f "$inf"
    echo "${session}: released by ${handle}"

    # Post to chat if configured
    if [[ -n "$CHAT_FILE" ]] && [[ -n "$CHAT_HANDLE" ]]; then
        local NBS_CHAT="${HOME}/.nbs/bin/nbs-chat"
        "$NBS_CHAT" send "$CHAT_FILE" "$CHAT_HANDLE" \
            "@team — I have released pty-session ${session}. It is now available." \
            2>/dev/null || true
    fi

    return 0
}

cmd_check() {
    local session="${1:-}"

    if [[ -z "$session" ]]; then
        echo "Error: check requires <session>" >&2
        return 4
    fi

    local inf
    inf=$(info_file "$session")

    if [[ ! -f "$inf" ]]; then
        echo "${session}: unlocked"
        return 0
    fi

    local holder
    holder=$(head -1 "$inf" 2>/dev/null || echo "unknown")
    local since
    since=$(tail -1 "$inf" 2>/dev/null || echo "unknown")

    echo "${session}: locked by ${holder} (since ${since})"
    return 0
}

# Main dispatch
case "${1:-}" in
    acquire)
        shift
        cmd_acquire "$@"
        ;;
    release)
        shift
        cmd_release "$@"
        ;;
    check)
        shift
        cmd_check "$@"
        ;;
    help|--help|-h|"")
        usage
        ;;
    *)
        echo "Unknown command: $1" >&2
        echo "Run 'pty-session-lock help' for usage" >&2
        exit 4
        ;;
esac
