#!/bin/bash
# nbs-worker: Worker lifecycle management for NBS teams
#
# Higher-level tool built on tmux for managing Claude worker instances.
# Handles naming, persistent logging, task file creation, and lifecycle.
#
# Usage:
#   nbs-worker spawn <slug> <project-dir> <task-description>
#   nbs-worker status <name>
#   nbs-worker search <name> <regex> [--context=N]
#   nbs-worker results <name>
#   nbs-worker dismiss <name>
#   nbs-worker continue <handle> [--model=MODEL]
#   nbs-worker session <handle>
#   nbs-worker list
#   nbs-worker help
#
# Names are generated as <slug>-<4-char-hash> to avoid collisions.
# Persistent logs are captured via tmux pipe-pane from session start.
# Task files are created automatically in .nbs/workers/<name>.md.
#
# Exit codes:
#   0 - Success
#   1 - General error
#   2 - Worker not found
#   3 - Timeout
#   4 - Invalid arguments

set -euo pipefail

PREFIX="pty_"
WORKERS_DIR="$(pwd)/.nbs/workers"
EVENTS_DIR="$(pwd)/.nbs/events"

# --- Bus integration ---

# Publish a bus event if the events directory and nbs-bus binary exist.
# Gracefully does nothing if the bus is not set up.
# Usage: bus_publish <source> <type> <priority> [payload]
bus_publish() {
    local source="$1"
    local type="$2"
    local priority="$3"
    local payload="${4:-}"

    # Find nbs-bus binary
    local nbs_bus=""
    if command -v nbs-bus >/dev/null 2>&1; then
        nbs_bus="nbs-bus"
    elif [[ -x "bin/nbs-bus" ]]; then
        nbs_bus="bin/nbs-bus"
    fi

    # No binary or no events dir — skip silently
    [[ -n "$nbs_bus" ]] || return 0
    [[ -d "$EVENTS_DIR" ]] || return 0

    if [[ -n "$payload" ]]; then
        if ! $nbs_bus publish "$EVENTS_DIR" "$source" "$type" "$priority" "$payload" >/dev/null 2>&1; then
            echo "Warning: bus publish failed (source=$source type=$type)" >&2
        fi
    else
        if ! $nbs_bus publish "$EVENTS_DIR" "$source" "$type" "$priority" >/dev/null 2>&1; then
            echo "Warning: bus publish failed (source=$source type=$type)" >&2
        fi
    fi
}

# --- Assertion helpers ---

assert_not_empty() {
    local var_name="$1"
    local var_value="$2"
    [[ -n "$var_value" ]] || {
        echo "ASSERTION FAILED: $var_name is empty" >&2
        exit 4
    }
}

assert_directory_exists() {
    local dir="$1"
    [[ -d "$dir" ]] || {
        echo "ASSERTION FAILED: Directory not found: $dir" >&2
        exit 1
    }
}

assert_file_exists() {
    local file="$1"
    [[ -f "$file" ]] || {
        echo "ASSERTION FAILED: File not found: $file" >&2
        exit 1
    }
}

# --- Core functions ---

usage() {
    cat <<'USAGE'
nbs-worker: Worker lifecycle management for NBS teams

Usage:
  nbs-worker spawn <slug> <project-dir> <task-description>
      Create task file, start Claude worker, send initial prompt.
      Returns the generated worker name (e.g., parser-a3f1).

  nbs-worker status <name>
      Report worker status from tmux session and task file State field.

  nbs-worker search <name> <regex> [--context=N]
      Search persistent log for regex matches with context (default 50).

  nbs-worker results <name>
      Extract Log section from completed task file.

  nbs-worker dismiss <name>
      Kill tmux session, mark task file as dismissed.

  nbs-worker continue <handle> [--model=MODEL]
      Resume an agent from its session metadata. Kills old tmux
      session, respawns with the saved session ID via claude --resume.
      Optionally override the model.

  nbs-worker session <handle>
      Display session metadata (session ID, model, PID, status).

  nbs-worker list
      Show all workers with status summary.

  nbs-worker help
      Show this help.

Exit codes:
  0 - Success
  1 - General error
  2 - Worker not found
  4 - Invalid arguments
USAGE
}

session_name() {
    echo "${PREFIX}$1"
}

generate_name() {
    local slug="$1"
    assert_not_empty "slug" "$slug"

    local hash
    hash=$(head -c 32 /dev/urandom | sha256sum | head -c 4)
    local name="${slug}-${hash}"

    # Postcondition: name matches expected format (fix 15)
    if [[ ! "$name" =~ ^[a-z0-9]+-[a-f0-9]{4}$ ]]; then
        echo "ASSERTION FAILED: generate_name produced invalid name: $name" >&2
        exit 1
    fi

    echo "$name"
}

task_file_path() {
    local name="$1"
    echo "${WORKERS_DIR}/${name}.md"
}

log_file_path() {
    local name="$1"
    echo "${WORKERS_DIR}/${name}.log"
}

worker_exists() {
    local name="$1"
    local task_file
    task_file=$(task_file_path "$name")
    [[ -f "$task_file" ]]
}

tmux_alive() {
    local name="$1"
    local session
    session=$(session_name "$name")
    tmux has-session -t "$session" 2>/dev/null
}

get_state_field() {
    local name="$1"
    local task_file
    task_file=$(task_file_path "$name")

    if [[ ! -f "$task_file" ]]; then
        echo "not found"
        return
    fi

    local state
    state=$(grep '^State:' "$task_file" 2>/dev/null | head -1 | sed 's/^State:[[:space:]]*//' || true)

    if [[ -z "$state" ]]; then
        echo "unknown"
    else
        echo "$state"
    fi
}

# --- Commands ---

cmd_spawn() {
    local slug="${1:-}"
    local project_dir="${2:-}"
    local task_description="${3:-}"

    if [[ -z "$slug" ]] || [[ -z "$project_dir" ]] || [[ -z "$task_description" ]]; then
        echo "Error: spawn requires <slug> <project-dir> <task-description>" >&2
        echo "Usage: nbs-worker spawn <slug> <project-dir> <task-description>" >&2
        return 4
    fi

    # Validate slug format: lowercase alphanumeric only (fix 16)
    if [[ ! "$slug" =~ ^[a-z0-9]+$ ]]; then
        echo "Error: slug must match ^[a-z0-9]+$ (got: $slug)" >&2
        return 4
    fi

    # Validate project directory exists
    if [[ ! -d "$project_dir" ]]; then
        echo "Error: Project directory not found: $project_dir" >&2
        return 1
    fi

    # Resolve project directory to absolute path
    local abs_project_dir
    abs_project_dir=$(cd "$project_dir" && pwd)

    # Workers directory is always relative to the project, not the caller's cwd
    local spawn_workers_dir="$abs_project_dir/.nbs/workers"

    # Ensure workers directory exists
    mkdir -p "$spawn_workers_dir"

    # Generate unique name
    local name
    name=$(generate_name "$slug")

    local task_file="${spawn_workers_dir}/${name}.md"
    local log_file="${spawn_workers_dir}/${name}.log"
    local session
    session=$(session_name "$name")

    # Precondition: name must not already exist (hash collision)
    if [[ -f "$task_file" ]]; then
        echo "Error: Name collision for '$name'. This should be extremely rare." >&2
        return 1
    fi

    # Create task file
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    cat > "$task_file" <<TASKEOF
# Worker: ${slug}

## Task

${task_description}

## Tooling

Your supervisor monitors you via \`nbs-worker\`. These tips avoid common mistakes:

- **Do not read raw .log files** — they contain ANSI escape codes. Use \`nbs-worker search <name> <regex>\` for clean, searchable output.
- **Update Status and Log sections** in this file when done — your supervisor reads them via \`nbs-worker results\`.
- **Escalate blockers** by setting State to \`escalated\` — do not work around problems silently.

## Status

State: running
Started: ${timestamp}
Completed:

## Log

[Worker appends findings here]
TASKEOF

    # Postcondition: task file was created
    assert_file_exists "$task_file"

    # Create tmux session
    # Escape single quotes in path to prevent shell injection (fix 2)
    local escaped_project_dir="${abs_project_dir//\'/\'\\\'\'}"
    if ! tmux new-session -d -s "$session" "cd '${escaped_project_dir}' && exec bash -l"; then
        echo "Error: Failed to create tmux session" >&2
        rm -f "$task_file"
        return 1
    fi

    # Start persistent logging via pipe-pane
    # This captures ALL output from session start, surviving session exit
    local escaped_log_file="${log_file//\'/\'\\\'\'}"
    if ! tmux pipe-pane -t "$session" -o "cat >> '${escaped_log_file}'"; then
        echo "Warning: pipe-pane failed — log capture may not work" >&2
    fi

    # Postcondition: tmux session is alive
    if ! tmux_alive "$name"; then
        echo "Error: tmux session died immediately after creation" >&2
        rm -f "$task_file"
        return 1
    fi

    # Allow shell to initialise
    sleep 2

    # Send the initial Claude command
    # SECURITY: --dangerously-skip-permissions is intentional for automated workers.
    # Workers run in isolated tmux sessions on tasks defined by the supervisor.
    # The supervisor (human) is responsible for reviewing worker output via
    # nbs-worker results/search before acting on it.
    tmux send-keys -t "$session" "claude --dangerously-skip-permissions" Enter

    # Allow Claude to start
    sleep 3

    # Send the task prompt (task_file is already an absolute path)
    tmux send-keys -t "$session" "Read ${task_file} and execute the task. Update the Status and Log sections when complete." Enter

    # Wait for Claude Code UI to be ready before sending confirmation Enter.
    # The UI needs time to render the welcome screen and display the prompt.
    # We poll the tmux pane for the prompt indicator (❯) which signals readiness.
    local wait_count=0
    local max_wait=30  # 30 seconds max
    while [ $wait_count -lt $max_wait ]; do
        if tmux capture-pane -t "$session" -p 2>/dev/null | grep -q '❯'; then
            break
        fi
        sleep 1
        wait_count=$((wait_count + 1))
    done

    # Warn if we timed out waiting for Claude UI (fix 7)
    if [[ $wait_count -ge $max_wait ]]; then
        echo "Warning: timed out waiting for Claude UI prompt (${max_wait}s)" >&2
    fi

    # Extra Enter for reliability — ensures prompt submission
    sleep 1
    tmux send-keys -t "$session" "" Enter

    # Publish bus event
    bus_publish "$name" "worker-spawned" "normal" "Task: ${task_description}"

    echo "$name"
    echo "  project:   $abs_project_dir" >&2
    echo "  task file:  $task_file" >&2
    echo "  log file:   $log_file" >&2
    echo "  tmux:       $session" >&2
    echo "  note: run nbs-worker commands from $abs_project_dir" >&2
    return 0
}

cmd_status() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        echo "Error: status requires <name>" >&2
        return 4
    fi

    if ! worker_exists "$name"; then
        echo "Error: Worker '$name' not found" >&2
        return 2
    fi

    local alive="no"
    if tmux_alive "$name"; then
        alive="yes"
    fi

    local state
    state=$(get_state_field "$name")

    # Status truth table:
    # tmux alive | State field      | Reported status
    # yes        | running          | running
    # yes        | completed        | completed (session still open)
    # no         | running          | died (session exited unexpectedly)
    # no         | completed        | completed
    # no         | failed/escalated | failed/escalated
    # —          | not found        | unknown

    local reported_status
    if [[ "$state" == "not found" ]] || [[ "$state" == "unknown" ]]; then
        reported_status="unknown"
    elif [[ "$alive" == "yes" ]] && [[ "$state" == "running" ]]; then
        reported_status="running"
    elif [[ "$alive" == "yes" ]] && [[ "$state" == "completed" ]]; then
        reported_status="completed (session still open)"
    elif [[ "$alive" == "no" ]] && [[ "$state" == "running" ]]; then
        reported_status="died (session exited unexpectedly)"
    elif [[ "$alive" == "no" ]] && [[ "$state" == "completed" ]]; then
        reported_status="completed"
    elif [[ "$alive" == "no" ]]; then
        reported_status="$state"
    else
        reported_status="$state"
    fi

    echo "Worker: $name"
    echo "  tmux session: $alive"
    echo "  task state:   $state"
    echo "  status:       $reported_status"

    # Publish bus event for dead workers that are still marked as running
    if [[ "$reported_status" == "died (session exited unexpectedly)" ]]; then
        bus_publish "$name" "worker-died" "high" "Worker $name: tmux dead but state still running"
    fi

    return 0
}

cmd_search() {
    # Fix 6: Explicit argument count check instead of fragile shift
    if [[ $# -lt 2 ]]; then
        echo "Error: search requires <name> <regex> [--context=N]" >&2
        return 4
    fi

    local name="$1"
    local pattern="$2"
    shift 2
    local context=50

    # Parse --context option
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --context=*)
                context="${1#--context=}"
                shift
                ;;
            *)
                # Fix 14 (partial): warn on unknown args in search
                echo "Warning: unknown argument ignored: $1" >&2
                shift
                ;;
        esac
    done

    if [[ -z "$name" ]] || [[ -z "$pattern" ]]; then
        echo "Error: search requires <name> <regex> [--context=N]" >&2
        return 4
    fi

    # Fix 5 (SECURITY): Validate name against path traversal
    if [[ ! "$name" =~ ^[a-z0-9]+-[a-f0-9]{4}$ ]]; then
        echo "Error: invalid worker name format: $name (expected <slug>-<4hex>)" >&2
        return 4
    fi

    local log_file
    log_file=$(log_file_path "$name")

    if [[ ! -f "$log_file" ]]; then
        echo "Error: No log file found for worker '$name'" >&2
        echo "Log file expected at: $log_file" >&2
        return 2
    fi

    # Fix 4 (SECURITY): Validate regex with a dry-run against empty input
    # grep returns 1 for "no match" and 2 for "invalid regex"
    local regex_test_rc=0
    echo "" | grep -E "$pattern" >/dev/null 2>&1 || regex_test_rc=$?
    if [[ $regex_test_rc -eq 2 ]]; then
        echo "Error: invalid regex pattern: $pattern" >&2
        return 4
    fi

    # Strip ANSI escape codes then search with context
    # Handles: CSI sequences (colours, cursor), OSC sequences, simple escapes
    # Fix 8 (BUG): Separate sed and grep to capture grep's actual return code
    local cleaned_log
    cleaned_log=$(sed 's/\x1b\[[0-9;]*[a-zA-Z]//g; s/\x1b\][^\x07]*\x07//g; s/\x1b[()][0-9A-B]//g' "$log_file")

    local rc=0
    echo "$cleaned_log" | grep -E -C "$context" "$pattern" || rc=$?

    if [[ $rc -eq 1 ]]; then
        echo "No matches found for pattern: $pattern" >&2
        return 1
    fi

    return $rc
}

cmd_results() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        echo "Error: results requires <name>" >&2
        return 4
    fi

    local task_file
    task_file=$(task_file_path "$name")

    if [[ ! -f "$task_file" ]]; then
        echo "Error: Task file not found for worker '$name'" >&2
        return 2
    fi

    # Extract the Log section from the task file
    # Everything from "## Log" to the next "## " heading or end of file
    local in_log=false
    local found_log=false

    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" == "## Log" ]]; then
            in_log=true
            found_log=true
            echo "$line"
            continue
        fi

        if [[ "$in_log" == true ]]; then
            # Stop at next ## heading (but not ### or deeper)
            if [[ "$line" =~ ^##[[:space:]] ]] && [[ ! "$line" =~ ^###  ]]; then
                break
            fi
            echo "$line"
        fi
    done < "$task_file"

    if [[ "$found_log" == false ]]; then
        echo "No Log section found in task file for worker '$name'" >&2
        return 1
    fi

    return 0
}

cmd_dismiss() {
    local name="${1:-}"

    if [[ -z "$name" ]]; then
        echo "Error: dismiss requires <name>" >&2
        return 4
    fi

    if ! worker_exists "$name"; then
        echo "Error: Worker '$name' not found" >&2
        return 2
    fi

    local session
    session=$(session_name "$name")

    # Kill tmux session if alive
    if tmux_alive "$name"; then
        # Fix 9 (BUG): Check return code of kill-session, warn on failure
        if tmux kill-session -t "$session" 2>/dev/null; then
            echo "Killed tmux session: $session"
        else
            echo "Warning: tmux kill-session failed for $session" >&2
        fi
    else
        echo "tmux session already dead"
    fi

    # Update task file state to dismissed
    local task_file
    task_file=$(task_file_path "$name")

    if [[ -f "$task_file" ]]; then
        local timestamp
        timestamp=$(date '+%Y-%m-%d %H:%M:%S')

        # Update State field
        if grep -q '^State:' "$task_file"; then
            sed -i "s/^State:.*/State: dismissed/" "$task_file"
        fi

        # Fill Completed timestamp if empty
        if grep -q '^Completed:$' "$task_file" 2>/dev/null; then
            sed -i "s/^Completed:$/Completed: ${timestamp}/" "$task_file"
        elif grep -q '^Completed:[[:space:]]*$' "$task_file" 2>/dev/null; then
            sed -i "s/^Completed:[[:space:]]*$/Completed: ${timestamp}/" "$task_file"
        fi
    fi

    # Postcondition: log file is preserved
    local log_file
    log_file=$(log_file_path "$name")
    if [[ -f "$log_file" ]]; then
        echo "Log preserved: $log_file"
    else
        echo "Note: No log file found (worker may not have produced output)"
    fi

    # Publish bus event
    bus_publish "$name" "worker-dismissed" "normal"

    # Clean session metadata (stale after dismiss)
    local session_meta="${SESSIONS_DIR}/${name}.json"
    rm -f "$session_meta" 2>/dev/null || true

    echo "Dismissed: $name"
    return 0
}

cmd_list() {
    echo "NBS Workers:"

    local has_workers=false

    # Check workers directory exists
    if [[ ! -d "$WORKERS_DIR" ]]; then
        echo "  (no workers directory)"
        return 0
    fi

    # Find all task files
    shopt -s nullglob
    for task_file in "${WORKERS_DIR}"/*.md; do
        [[ -f "$task_file" ]] || continue

        local filename
        filename=$(basename "$task_file" .md)

        # Skip files that don't look like worker task files (e.g., worker-001.md from old format)
        # nbs-worker names always have a 4-char hash suffix after a dash

        local state
        state=$(grep '^State:' "$task_file" 2>/dev/null | head -1 | sed 's/^State:[[:space:]]*//' || true)
        [[ -z "$state" ]] && state="unknown"

        local alive="dead"
        if tmux has-session -t "${PREFIX}${filename}" 2>/dev/null; then
            alive="alive"
        fi

        local log_exists="no-log"
        if [[ -f "${WORKERS_DIR}/${filename}.log" ]]; then
            local log_size
            log_size=$(wc -c < "${WORKERS_DIR}/${filename}.log" 2>/dev/null || echo "0")
            log_exists="log:${log_size}B"
        fi

        printf "  %-25s %-12s tmux:%-5s %s\n" "$filename" "$state" "$alive" "$log_exists"
        has_workers=true
    done
    shopt -u nullglob

    if [[ "$has_workers" == false ]]; then
        echo "  (none)"
    fi
}

# --- Session metadata commands ---

SESSIONS_DIR="$(pwd)/.nbs/sessions"

cmd_session() {
    local handle="${1:-}"

    if [[ -z "$handle" ]]; then
        echo "Error: session requires <handle>" >&2
        echo "Usage: nbs-worker session <handle>" >&2
        return 4
    fi

    local meta_file="${SESSIONS_DIR}/${handle}.json"

    if [[ ! -f "$meta_file" ]]; then
        echo "No session metadata for handle '$handle'" >&2
        echo "  Expected: $meta_file" >&2
        echo "  The agent may not have been started with nbs-claude, or has exited." >&2
        return 2
    fi

    echo "Session metadata for '$handle':"
    echo "  File: $meta_file"

    # Parse JSON fields (minimal, no jq dependency)
    local session_id model started pid project_root tmux_session
    session_id=$(grep '"session_id"' "$meta_file" | sed 's/.*: *"//;s/".*//' || echo "unknown")
    model=$(grep '"model"' "$meta_file" | sed 's/.*: *"//;s/".*//' || echo "")
    started=$(grep '"started"' "$meta_file" | sed 's/.*: *"//;s/".*//' || echo "unknown")
    pid=$(grep '"pid"' "$meta_file" | sed 's/.*: *//;s/[^0-9].*//' || echo "0")
    project_root=$(grep '"project_root"' "$meta_file" | sed 's/.*: *"//;s/".*//' || echo "unknown")
    tmux_session=$(grep '"tmux_session"' "$meta_file" | sed 's/.*: *"//;s/".*//' || echo "unknown")

    echo "  Session ID: $session_id"
    echo "  Model: ${model:-<default>}"
    echo "  Started: $started"
    echo "  Tmux: $tmux_session"
    echo "  Project: $project_root"
    echo "  PID: $pid"

    # Check if PID is alive
    if [[ "$pid" -gt 0 ]] && kill -0 "$pid" 2>/dev/null; then
        echo "  Status: ALIVE"
    else
        echo "  Status: DEAD (PID $pid not running)"
    fi

    # Check tmux session
    if tmux has-session -t "$tmux_session" 2>/dev/null; then
        echo "  Tmux session: ALIVE"
    else
        echo "  Tmux session: NOT FOUND"
    fi

    return 0
}

cmd_continue() {
    local handle="${1:-}"
    shift || true

    if [[ -z "$handle" ]]; then
        echo "Error: continue requires <handle>" >&2
        echo "Usage: nbs-worker continue <handle> [--model=MODEL]" >&2
        return 4
    fi

    local meta_file="${SESSIONS_DIR}/${handle}.json"
    local model_override=""

    # Parse optional args
    for arg in "$@"; do
        case "$arg" in
            --model=*)
                model_override="${arg#--model=}"
                ;;
            *)
                echo "Error: unknown argument: $arg" >&2
                return 4
                ;;
        esac
    done

    if [[ ! -f "$meta_file" ]]; then
        echo "Error: No session metadata for handle '$handle'" >&2
        echo "  Expected: $meta_file" >&2
        echo "  Cannot continue without session ID. Use 'nbs-worker spawn' for a fresh start." >&2
        return 2
    fi

    # Read session metadata
    local session_id model project_root tmux_session old_pid
    session_id=$(grep '"session_id"' "$meta_file" | sed 's/.*: *"//;s/".*//')
    model=$(grep '"model"' "$meta_file" | sed 's/.*: *"//;s/".*//')
    project_root=$(grep '"project_root"' "$meta_file" | sed 's/.*: *"//;s/".*//')
    tmux_session=$(grep '"tmux_session"' "$meta_file" | sed 's/.*: *"//;s/".*//')
    old_pid=$(grep '"pid"' "$meta_file" | sed 's/.*: *//;s/[^0-9].*//')

    # Validate session ID format (UUID)
    if [[ ! "$session_id" =~ ^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ ]]; then
        echo "Error: Invalid session ID in metadata: '$session_id'" >&2
        echo "  Cannot resume with a non-UUID session ID." >&2
        return 1
    fi

    # Apply model override if given
    if [[ -n "$model_override" ]]; then
        model="$model_override"
    fi

    echo "Continuing agent '$handle':"
    echo "  Session ID: $session_id"
    echo "  Model: ${model:-<default>}"
    echo "  Project: $project_root"
    echo "  Tmux session: $tmux_session"

    # Kill old tmux session if still running
    if tmux has-session -t "$tmux_session" 2>/dev/null; then
        echo "  Killing old tmux session..."
        tmux kill-session -t "$tmux_session" 2>/dev/null || true
        sleep 1
    fi

    # Clean stale pidfile
    local pidfile="${project_root}/.nbs/pids/${handle}.pid"
    if [[ -f "$pidfile" ]]; then
        local existing_pid
        existing_pid=$(cat "$pidfile" 2>/dev/null || echo "")
        if [[ -n "$existing_pid" ]] && ! kill -0 "$existing_pid" 2>/dev/null; then
            rm -f "$pidfile"
        fi
    fi

    # Build nbs-claude command
    local nbs_claude_cmd="NBS_HANDLE=${handle}"
    if [[ -n "$model" ]]; then
        nbs_claude_cmd="${nbs_claude_cmd} NBS_MODEL=${model}"
    fi
    nbs_claude_cmd="${nbs_claude_cmd} bin/nbs-claude --continue=${session_id} --dangerously-skip-permissions"

    # Respawn in tmux
    echo "  Spawning: $nbs_claude_cmd"
    tmux new-session -d -s "$tmux_session" -c "$project_root" "$nbs_claude_cmd"

    # Wait and verify
    sleep 3
    if tmux has-session -t "$tmux_session" 2>/dev/null; then
        echo "  Continued successfully in tmux session: $tmux_session"
    else
        echo "  Warning: tmux session did not start" >&2
        return 1
    fi

    # Publish bus event
    bus_publish "$handle" "worker-continued" "normal" "Continued session $session_id"

    return 0
}

# --- Main dispatch ---

case "${1:-}" in
    spawn)
        shift
        cmd_spawn "$@"
        ;;
    status)
        shift
        cmd_status "$@"
        ;;
    search)
        shift
        cmd_search "$@"
        ;;
    results)
        shift
        cmd_results "$@"
        ;;
    dismiss)
        shift
        cmd_dismiss "$@"
        ;;
    continue)
        shift
        cmd_continue "$@"
        ;;
    session)
        shift
        cmd_session "$@"
        ;;
    list)
        cmd_list
        ;;
    help|--help|-h|"")
        usage
        ;;
    *)
        echo "Unknown command: $1" >&2
        echo "Run 'nbs-worker help' for usage" >&2
        exit 4
        ;;
esac
