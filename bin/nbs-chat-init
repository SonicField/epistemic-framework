#!/bin/bash
# nbs-chat-init: Bootstrap NBS framework infrastructure for a project
#
# Creates the tripod (bus, chat, scribe log) and optionally spawns AI
# instances via tmux. This script is both executable automation and
# living documentation — read it to understand how the system fits
# together.
#
# Usage:
#   nbs-chat-init --name=NAME [OPTIONS]
#
#   --name=NAME           Chat name (required) — all resource names derive from this
#   --project-name=NAME   Override project name (default: dirname of pwd)
#   --force               Skip confirmation prompts
#   --dry-run             Print actions without executing
#   --spawn-scribe        Launch Scribe in tmux session
#   --spawn-pythia        Launch Pythia in tmux session
#   --spawn-all           Launch Scribe + Pythia + main Claude instance
#   --spawn-only          Skip infrastructure, just spawn agents (for restart)
#   --compact-log         Archive decision log if it exceeds threshold
#   --help                Show usage
#
# Exit codes:
#   0 - Success
#   1 - General error
#   4 - Invalid arguments
#
# Infrastructure created:
#   .nbs/events/           Bus event queue
#   .nbs/events/processed/ Acknowledged events
#   .nbs/events/config.yaml Bus + Pythia configuration
#   .nbs/chat/<name>.chat  Primary chat channel
#   .nbs/chat/archive/     Archived previous chats
#   .nbs/scribe/<name>-log.md Decision log (Scribe's output)
#   .nbs/project-id        4-char project identifier
#
# Tmux sessions (optional, named after chat):
#   nbs-scribe-<name>      Scribe instance (--spawn-scribe or --spawn-all)
#   nbs-pythia-<name>      Pythia instance (--spawn-pythia or --spawn-all)
#   nbs-claude-<name>      Main Claude instance (--spawn-all)

set -euo pipefail

# --- Configuration ---

# Violation 11 (HARDENING): Resolve PROJECT_ROOT to absolute path.
PROJECT_ROOT="$(cd "$(pwd)" && pwd -P)"
PROJECT_NAME=""
FORCE=false
DRY_RUN=false
SPAWN_SCRIBE=false
SPAWN_PYTHIA=false
SPAWN_ALL=false
SPAWN_ONLY=false
COMPACT_LOG=false
PROJECT_ID=""
CHAT_NAME=""  # Set via --name= (required)

# --- Output helpers ---

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

info()  { echo -e "${BLUE}[nbs-chat-init]${NC} $*"; }
ok()    { echo -e "${GREEN}[nbs-chat-init]${NC} $*"; }
warn()  { echo -e "${YELLOW}[nbs-chat-init]${NC} $*"; }
error() { echo -e "${RED}[nbs-chat-init]${NC} $*" >&2; }

# --- CHAT_NAME validation ---
# Violation 3 (SECURITY): CHAT_NAME used unsanitised in tmux session names.
# Restrict to safe characters to prevent tmux session name injection.
validate_chat_name() {
    local name="$1"
    if [[ ! "$name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        error "CHAT_NAME contains invalid characters: '$name'"
        error "Allowed: alphanumeric, hyphen, underscore (regex: ^[a-zA-Z0-9_-]+\$)"
        exit 4
    fi
}

# --- Dry-run wrapper ---
# Every side-effectful operation goes through run().
# In dry-run mode, the command is printed but not executed.
# Reading the dry-run output is equivalent to reading a specification.

run() {
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "  ${YELLOW}[DRY-RUN]${NC} $*"
        return 0
    fi
    "$@"
}

# --- Assertion helpers ---

assert_not_empty() {
    local var_name="$1"
    local var_value="$2"
    [[ -n "$var_value" ]] || {
        error "ASSERTION FAILED: $var_name is empty"
        exit 4
    }
}

assert_tool_exists() {
    local tool="$1"
    command -v "$tool" >/dev/null 2>&1 || {
        error "Required tool not found: $tool"
        error "Ensure NBS tools are installed and on PATH."
        error "Run: ./bin/install.sh"
        exit 1
    }
}

assert_directory_exists() {
    local dir="$1"
    [[ -d "$dir" ]] || {
        error "ASSERTION FAILED: Directory not found: $dir"
        exit 1
    }
}

assert_file_exists() {
    local file="$1"
    [[ -f "$file" ]] || {
        error "ASSERTION FAILED: File not found: $file"
        exit 1
    }
}

# --- Interaction ---

confirm() {
    local message="$1"
    if [[ "$FORCE" == "true" ]]; then
        return 0
    fi
    read -rp "$(echo -e "${YELLOW}[nbs-chat-init]${NC} $message [y/N]: ")" answer
    case "$answer" in
        [Yy]|[Yy]es) return 0 ;;
        *) return 1 ;;
    esac
}

# --- Project identity ---

generate_project_id() {
    local path="$1"
    assert_not_empty "path" "$path"
    # Violation 10 (HARDENING): Check sha256sum return value.
    local hash
    hash=$(echo -n "$path" | sha256sum) || {
        error "sha256sum failed for project ID generation"
        exit 1
    }
    echo "$hash" | head -c 4
}

tmux_session_name() {
    local role="$1"
    echo "nbs-${role}-${CHAT_NAME}"
}

# --- Argument parsing ---

for arg in "$@"; do
    case "$arg" in
        --name=*)
            CHAT_NAME="${arg#--name=}"
            ;;
        --project-name=*)
            PROJECT_NAME="${arg#--project-name=}"
            ;;
        --force)
            FORCE=true
            ;;
        --dry-run)
            DRY_RUN=true
            ;;
        --spawn-scribe)
            SPAWN_SCRIBE=true
            ;;
        --spawn-pythia)
            SPAWN_PYTHIA=true
            ;;
        --spawn-all)
            SPAWN_ALL=true
            SPAWN_SCRIBE=true
            SPAWN_PYTHIA=true
            ;;
        --spawn-only)
            SPAWN_ONLY=true
            ;;
        --compact-log)
            COMPACT_LOG=true
            ;;
        --help|-h)
            cat <<'USAGE'
nbs-chat-init: Bootstrap NBS framework infrastructure

Usage: nbs-chat-init --name=NAME [OPTIONS]

Required:
  --name=NAME             Chat name — all resource names derive from this

Options:
  --project-name=NAME     Override project name (default: dirname of pwd)
  --force                 Skip confirmation prompts
  --dry-run               Print actions without executing
  --spawn-scribe          Launch Scribe in tmux session
  --spawn-pythia          Launch Pythia in tmux session
  --spawn-all             Launch Scribe + Pythia + main Claude instance
  --spawn-only            Skip infrastructure creation, just spawn agents (for restart)
  --compact-log           Archive decision log if it exceeds threshold (100 entries)
  --help                  Show this help

Infrastructure created:
  .nbs/events/            Event bus queue
  .nbs/chat/<name>.chat   Primary chat channel
  .nbs/scribe/<name>-log.md Decision log

Spawn only (restart after reboot):
  nbs-chat-init --name=NAME --spawn-only --spawn-scribe
  nbs-chat-init --name=NAME --spawn-only --spawn-all

Join an existing chat (human):
  nbs-chat-terminal .nbs/chat/<name>.chat <your-handle>

Join an existing chat (additional agent):
  NBS_HANDLE=<unique-name> nbs-claude

Exit codes:
  0 - Success
  1 - General error
  4 - Invalid arguments
USAGE
            exit 0
            ;;
        *)
            error "Unknown argument: $arg"
            error "Run: nbs-chat-init --help"
            exit 4
            ;;
    esac
done

# --- Validate arguments ---

if [[ -z "$CHAT_NAME" ]]; then
    error "Missing required argument: --name=NAME"
    error "Run: nbs-chat-init --help"
    exit 4
fi

# Violation 3 (SECURITY): Validate CHAT_NAME before use in tmux session names.
validate_chat_name "$CHAT_NAME"

# Violation 8 (HARDENING): Assert PROJECT_ROOT is a valid directory.
assert_directory_exists "$PROJECT_ROOT"

if [[ "$SPAWN_ONLY" == "true" ]] && [[ "$SPAWN_SCRIBE" != "true" ]] && [[ "$SPAWN_PYTHIA" != "true" ]] && [[ "$SPAWN_ALL" != "true" ]]; then
    error "--spawn-only requires --spawn-scribe, --spawn-pythia, or --spawn-all"
    exit 4
fi

# --- Derived paths (all resource names derive from CHAT_NAME) ---
# Violation 11 (HARDENING): Resolve all derived paths to absolute.

CHAT_FILE="${PROJECT_ROOT}/.nbs/chat/${CHAT_NAME}.chat"
CHAT_CURSORS="${CHAT_FILE}.cursors"
CHAT_LOCK="${CHAT_FILE}.lock"
SCRIBE_LOG="${PROJECT_ROOT}/.nbs/scribe/${CHAT_NAME}-log.md"

# --- Validate prerequisites ---

info "Checking prerequisites..."
# Violation 14 (HARDENING): Assert all required binaries exist.
assert_tool_exists "nbs-chat"
assert_tool_exists "nbs-bus"
assert_tool_exists "sha256sum"
assert_tool_exists "date"
assert_tool_exists "grep"
assert_tool_exists "sed"
assert_tool_exists "basename"

if [[ "$SPAWN_SCRIBE" == "true" ]] || [[ "$SPAWN_PYTHIA" == "true" ]] || [[ "$SPAWN_ALL" == "true" ]]; then
    assert_tool_exists "tmux"
    assert_tool_exists "nbs-claude"
fi

# --- Project detection ---

if [[ -z "$PROJECT_NAME" ]]; then
    PROJECT_NAME="$(basename "$PROJECT_ROOT")"
fi

PROJECT_ID=$(generate_project_id "$PROJECT_ROOT")

echo ""
echo -e "${BOLD}NBS Init${NC}"
echo "  Project:    $PROJECT_NAME"
echo "  Chat name:  $CHAT_NAME"
echo "  Root:       $PROJECT_ROOT"
echo "  Project ID: $PROJECT_ID"
if [[ "$DRY_RUN" == "true" ]]; then
    echo -e "  Mode:       ${YELLOW}DRY RUN${NC}"
fi
if [[ "$SPAWN_ONLY" == "true" ]]; then
    echo -e "  Mode:       ${YELLOW}SPAWN ONLY${NC}"
fi
echo ""

# ============================================================
# PHASES 1-4: Infrastructure Creation (skipped in spawn-only mode)
# ============================================================

if [[ "$SPAWN_ONLY" != "true" ]]; then

# Check for existing .nbs/
if [[ -d ".nbs" ]]; then
    warn "Existing .nbs/ directory found."
    if ! confirm "Re-initialise? (existing data will be preserved)"; then
        info "Cancelled."
        exit 0
    fi
fi

# ============================================================
# PHASE 1: Bus Infrastructure
# ============================================================

info "Phase 1: Event bus..."

# 1.1 Create bus directories
run mkdir -p .nbs/events/processed

# 1.2 Write config (only if missing)
if [[ ! -f ".nbs/events/config.yaml" ]] || [[ "$DRY_RUN" == "true" ]]; then
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "  ${YELLOW}[DRY-RUN]${NC} Write .nbs/events/config.yaml (defaults)"
    else
        # Violation 7 (BUG): cat heredoc bypasses run(). This is intentional:
        # the enclosing DRY_RUN guard prevents execution in dry-run mode,
        # and cat heredocs cannot be meaningfully routed through run().
        cat > .nbs/events/config.yaml << 'CONFIGEOF'
# NBS Event Bus Configuration
#
# dedup-window:  Seconds to suppress duplicate events (default: 0 = disabled)
#                System events use this as the default. Chat events pass
#                --dedup-window=0 to nbs-bus to bypass dedup entirely.
# ack-timeout:   Seconds before unacknowledged events are flagged stale (default: 120)
# pythia-interval: Scribe decisions between Pythia checkpoints (default: 10)
# retention-max-bytes: Maximum total size of processed events before pruning (default: 16MB)

dedup-window: 300
ack-timeout: 120
pythia-interval: 10
retention-max-bytes: 16777216
CONFIGEOF
        ok "  config.yaml written"
    fi
else
    info "  config.yaml already exists — keeping"
fi

# 1.3 Bus self-test: publish, check, ack, verify
info "  Bus self-test..."
if [[ "$DRY_RUN" == "true" ]]; then
    echo -e "  ${YELLOW}[DRY-RUN]${NC} nbs-bus publish → check → ack → verify"
else
    # Use a unique event type per invocation to avoid dedup window collisions
    SELF_TEST_TYPE="self-test-$(date +%s)"

    # Publish a test event
    # Violation 4 (BUG): Check nbs-bus publish return value.
    if ! nbs-bus publish .nbs/events/ nbs-chat-init "$SELF_TEST_TYPE" low "nbs-chat-init self-test" >/dev/null 2>&1; then
        warn "  nbs-bus publish failed during self-test (exit $?)"
    fi

    # Find and acknowledge it
    # Violation 1 (SECURITY): Use find with -print0 instead of unquoted glob + ls + xargs.
    SELF_TEST_EVENT=$(find .nbs/events/ -maxdepth 1 -name "*nbs-chat-init*self-test*.event" -print0 2>/dev/null \
        | xargs -0 -r -n1 basename 2>/dev/null | head -1)
    if [[ -n "$SELF_TEST_EVENT" ]]; then
        # Violation 13 (HARDENING): Check nbs-bus ack return value, log warning on failure.
        if ! nbs-bus ack .nbs/events/ "$SELF_TEST_EVENT" >/dev/null 2>&1; then
            warn "  nbs-bus ack failed for self-test event '$SELF_TEST_EVENT'"
        fi

        # Verify it reached processed/
        if [[ -f ".nbs/events/processed/$SELF_TEST_EVENT" ]]; then
            ok "  Bus self-test passed"
        else
            error "  Bus self-test: event not found in processed/"
            exit 1
        fi
    else
        # If no event was created, the bus binary may have deduped it or failed.
        # Fall back to checking bus status — if status works, the bus is operational.
        if nbs-bus status .nbs/events/ >/dev/null 2>&1; then
            ok "  Bus self-test passed (via status check)"
        else
            error "  Bus self-test: no event file created and status check failed"
            exit 1
        fi
    fi
fi

# ============================================================
# PHASE 2: Chat
# ============================================================

info "Phase 2: Chat..."

run mkdir -p .nbs/chat/archive

# 2.1 Archive existing chat (if present)
if [[ -f "$CHAT_FILE" ]]; then
    ARCHIVE_TS=$(date +%Y%m%d_%H%M%S)
    ARCHIVE_NAME="${CHAT_NAME}-${ARCHIVE_TS}.chat"
    info "  Archiving existing ${CHAT_NAME}.chat → archive/$ARCHIVE_NAME"
    run mv "$CHAT_FILE" ".nbs/chat/archive/$ARCHIVE_NAME"
    if [[ -f "$CHAT_CURSORS" ]]; then
        run mv "$CHAT_CURSORS" ".nbs/chat/archive/${ARCHIVE_NAME}.cursors"
    fi
    if [[ -f "$CHAT_LOCK" ]]; then
        run rm -f "$CHAT_LOCK"
    fi
fi

# 2.2 Create fresh chat
if [[ "$DRY_RUN" == "true" ]]; then
    echo -e "  ${YELLOW}[DRY-RUN]${NC} nbs-chat create $CHAT_FILE"
else
    # Violation 5 (BUG): Check nbs-chat create return value.
    if ! nbs-chat create "$CHAT_FILE" >/dev/null 2>&1; then
        error "nbs-chat create failed for '$CHAT_FILE'"
        exit 1
    fi
    ok "  ${CHAT_NAME}.chat created"
fi

# 2.3 Post init message
if [[ "$DRY_RUN" == "true" ]]; then
    echo -e "  ${YELLOW}[DRY-RUN]${NC} nbs-chat send init message"
else
    # Violation 5 (BUG): Check nbs-chat send return value.
    if ! nbs-chat send "$CHAT_FILE" nbs-chat-init \
        "Project '$PROJECT_NAME' initialised (project-id: $PROJECT_ID). Bus, chat, and scribe log are ready." \
        >/dev/null 2>&1; then
        error "nbs-chat send failed for init message"
        exit 1
    fi
    ok "  Init message posted"
fi

# ============================================================
# PHASE 3: Scribe Log
# ============================================================

info "Phase 3: Scribe log..."

run mkdir -p .nbs/scribe

if [[ ! -f "$SCRIBE_LOG" ]] || [[ "$DRY_RUN" == "true" ]]; then
    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "  ${YELLOW}[DRY-RUN]${NC} Write $SCRIBE_LOG (header)"
    else
        CREATED_TS=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        # Violation 7 (BUG): cat heredoc bypasses run(). Intentional — guarded by DRY_RUN check above.
        cat > "$SCRIBE_LOG" << LOGEOF
# Decision Log

Project: $PROJECT_NAME
Created: $CREATED_TS
Scribe: scribe
Chat: ${CHAT_NAME}.chat
Decision count: 0

---
LOGEOF
        ok "  ${CHAT_NAME}-log.md created"
    fi
else
    info "  ${CHAT_NAME}-log.md already exists — keeping"
fi

# --- Log compaction (progressive archival) ---
# If the decision log exceeds 100 entries, archive it and start a new one.
# The first record in the new log points to the archive (linked list).
# Triggered automatically during init or manually with --compact-log.

COMPACT_THRESHOLD=100

compact_decision_log() {
    local log_file="$1"
    local entry_count
    entry_count=$(grep -c '^### D-' "$log_file" 2>/dev/null || echo 0)

    if [[ "${entry_count:-0}" -lt "$COMPACT_THRESHOLD" ]] && [[ "$COMPACT_LOG" != "true" ]]; then
        info "  Decision log: $entry_count entries (threshold: $COMPACT_THRESHOLD) — no compaction needed"
        return 0
    fi

    if [[ "${entry_count:-0}" -eq 0 ]]; then
        info "  Decision log: empty — nothing to compact"
        return 0
    fi

    local archive_ts
    archive_ts=$(date +%Y%m%d-%H%M%S)
    local archive_file=".nbs/scribe/${CHAT_NAME}-log-archive-${archive_ts}.md"

    if [[ "$DRY_RUN" == "true" ]]; then
        echo -e "  ${YELLOW}[DRY-RUN]${NC} Archive $log_file ($entry_count entries) → $archive_file"
        echo -e "  ${YELLOW}[DRY-RUN]${NC} Create new $log_file with link to archive"
        return 0
    fi

    # Move current log to archive
    # Violation 7 (BUG): Route mv through run() for dry-run compatibility.
    run mv "$log_file" "$archive_file"

    # Extract header fields from the archive for the new log
    local project_name
    project_name=$(grep '^Project:' "$archive_file" | head -1 | sed 's/^Project: //')
    local chat_ref
    chat_ref=$(grep '^Chat:' "$archive_file" | head -1 | sed 's/^Chat: //')
    local created_ts
    created_ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Create new log with link to archive as first record
    # Violation 7 (BUG): cat heredoc bypasses run(). Intentional — guarded by DRY_RUN check above.
    cat > "$log_file" << COMPACTEOF
# Decision Log

Project: ${project_name:-$PROJECT_NAME}
Created: $created_ts
Scribe: scribe
Chat: ${chat_ref:-${CHAT_NAME}.chat}
Decision count: 0
Previous log: $archive_file

---

### ARCHIVE-LINK
- **Previous log:** \`$archive_file\`
- **Entries archived:** $entry_count
- **Archived at:** $created_ts
- **Rationale:** Decision log exceeded compaction threshold ($COMPACT_THRESHOLD entries). All previous decisions are preserved in the archive file. This is the continuation log.

---
COMPACTEOF

    ok "  Compacted: $entry_count entries archived → $archive_file"
    info "  New log created with link to archive"
}

if [[ -f "$SCRIBE_LOG" ]]; then
    compact_decision_log "$SCRIBE_LOG"
fi

# ============================================================
# PHASE 4: Project Identity
# ============================================================

info "Phase 4: Project identity..."

if [[ "$DRY_RUN" == "true" ]]; then
    echo -e "  ${YELLOW}[DRY-RUN]${NC} Write .nbs/project-id ($PROJECT_ID)"
else
    # Violation 7 (BUG): echo redirect bypasses run(). Intentional — guarded by DRY_RUN check above.
    echo "$PROJECT_ID" > .nbs/project-id
    ok "  project-id: $PROJECT_ID"
fi

fi  # end of SPAWN_ONLY != true

# ============================================================
# PHASE 5: Health Check
# ============================================================

info "Phase 5: Health check..."

if [[ "$DRY_RUN" == "true" ]]; then
    echo -e "  ${YELLOW}[DRY-RUN]${NC} nbs-bus status .nbs/events/"
    echo -e "  ${YELLOW}[DRY-RUN]${NC} nbs-chat read $CHAT_FILE"
    echo -e "  ${YELLOW}[DRY-RUN]${NC} Verify $SCRIBE_LOG header"
else
    HEALTH_PASS=true

    # Bus
    if nbs-bus status .nbs/events/ >/dev/null 2>&1; then
        ok "  Bus: operational"
    else
        error "  Bus: FAILED"
        HEALTH_PASS=false
    fi

    # Chat
    if nbs-chat read "$CHAT_FILE" >/dev/null 2>&1; then
        ok "  Chat: operational"
    else
        error "  Chat: FAILED"
        HEALTH_PASS=false
    fi

    # Scribe log
    if grep -q "^Project:" "$SCRIBE_LOG" 2>/dev/null && \
       grep -q "^Decision count:" "$SCRIBE_LOG" 2>/dev/null; then
        ok "  Scribe log: well-formed"
    else
        error "  Scribe log: FAILED (missing header fields)"
        HEALTH_PASS=false
    fi

    if [[ "$HEALTH_PASS" != "true" ]]; then
        error "Health check failed. Infrastructure may be incomplete."
        exit 1
    fi
fi

# ============================================================
# PHASE 6: AI Spawn (optional)
# ============================================================

if [[ "$SPAWN_SCRIBE" == "true" ]] || [[ "$SPAWN_PYTHIA" == "true" ]] || [[ "$SPAWN_ALL" == "true" ]]; then
    echo ""
    info "Phase 6: AI spawn..."

    # --- Scribe ---
    SCRIBE_SESSION=$(tmux_session_name "scribe")

    if tmux has-session -t "$SCRIBE_SESSION" 2>/dev/null; then
        warn "  tmux session '$SCRIBE_SESSION' already exists."
        if confirm "Kill existing session?"; then
            run tmux kill-session -t "$SCRIBE_SESSION"
        else
            warn "  Skipping Scribe spawn."
            SPAWN_SCRIBE=false
        fi
    fi

    if [[ "$SPAWN_SCRIBE" == "true" ]]; then
        info "  Spawning Scribe..."
        if [[ "$DRY_RUN" == "true" ]]; then
            echo -e "  ${YELLOW}[DRY-RUN]${NC} tmux new-session -d -s $SCRIBE_SESSION"
            echo -e "  ${YELLOW}[DRY-RUN]${NC} → NBS_HANDLE=scribe nbs-claude"
            echo -e "  ${YELLOW}[DRY-RUN]${NC} → Send Scribe role prompt"
        else
            # Create tmux session in the project directory
            tmux new-session -d -s "$SCRIBE_SESSION" -c "$PROJECT_ROOT"

            # Wait for shell to initialise
            sleep 2

            # Launch nbs-claude inside the session with unique handle
            # SECURITY RISK (Violation 2): --dangerously-skip-permissions bypasses Claude's
            # permission system, allowing the AI to execute any tool without user confirmation.
            # This is required for autonomous operation but means the AI can modify files,
            # execute commands, and access network resources without human approval.
            # TODO: Architectural decision needed — consider scoped permissions or audit logging.
            tmux send-keys -t "$SCRIBE_SESSION" "NBS_HANDLE=scribe nbs-claude --dangerously-skip-permissions" Enter

            # Wait for Claude to start
            sleep 3

            # Send the Scribe role prompt
            SCRIBE_PROMPT="You are the Scribe. Load /nbs-scribe. Your handle is 'scribe'. Monitor $CHAT_FILE and log decisions to $SCRIBE_LOG. Publish decision-logged bus events. Check pythia-interval threshold and publish pythia-checkpoint events when reached. Do not participate in conversation — only observe and record."

            # Wait for sidecar handle injection (proves CLI is fully ready)
            wait_count=0
            max_wait=60
            # Violation 12 (HARDENING): Use ${var:-0} in arithmetic to guard against unset.
            while [ "${wait_count:-0}" -lt "${max_wait:-60}" ]; do
                if tmux capture-pane -t "$SCRIBE_SESSION" -p 2>/dev/null | grep -q 'handle is'; then
                    break
                fi
                sleep 1
                wait_count=$((${wait_count:-0} + 1))
            done

            if [ "${wait_count:-0}" -ge "${max_wait:-60}" ]; then
                warn "  Scribe CLI did not become ready within ${max_wait}s"
            fi

            tmux send-keys -t "$SCRIBE_SESSION" "$SCRIBE_PROMPT" Enter

            # Extra Enter for reliability
            sleep 1
            tmux send-keys -t "$SCRIBE_SESSION" "" Enter

            ok "  Scribe spawned: $SCRIBE_SESSION"
            info "  Attach: tmux attach -t $SCRIBE_SESSION"
        fi
    fi

    # --- Pythia ---
    if [[ "$SPAWN_PYTHIA" == "true" ]]; then
        PYTHIA_SESSION=$(tmux_session_name "pythia")

        if tmux has-session -t "$PYTHIA_SESSION" 2>/dev/null; then
            warn "  tmux session '$PYTHIA_SESSION' already exists."
            if confirm "Kill existing session?"; then
                run tmux kill-session -t "$PYTHIA_SESSION"
            else
                warn "  Skipping Pythia spawn."
                SPAWN_PYTHIA=false
            fi
        fi

        if [[ "$SPAWN_PYTHIA" == "true" ]]; then
            info "  Spawning Pythia..."
            if [[ "$DRY_RUN" == "true" ]]; then
                echo -e "  ${YELLOW}[DRY-RUN]${NC} tmux new-session -d -s $PYTHIA_SESSION"
                echo -e "  ${YELLOW}[DRY-RUN]${NC} → NBS_HANDLE=pythia nbs-claude"
                echo -e "  ${YELLOW}[DRY-RUN]${NC} → Send Pythia role prompt"
            else
                tmux new-session -d -s "$PYTHIA_SESSION" -c "$PROJECT_ROOT"
                sleep 2
                # SECURITY RISK (Violation 2): See comment in Scribe spawn above.
                tmux send-keys -t "$PYTHIA_SESSION" "NBS_HANDLE=pythia nbs-claude --dangerously-skip-permissions" Enter
                sleep 3

                PYTHIA_PROMPT="You are Pythia — the oracle. Load /nbs-pythia. Your handle is 'pythia'. Read the decision log at $SCRIBE_LOG. Post your structured assessment to $CHAT_FILE. When your assessment is posted and the bus event published, exit."

                # Wait for sidecar handle injection (proves CLI is fully ready)
                wait_count=0
                max_wait=60
                # Violation 12 (HARDENING): Use ${var:-0} in arithmetic.
                while [ "${wait_count:-0}" -lt "${max_wait:-60}" ]; do
                    if tmux capture-pane -t "$PYTHIA_SESSION" -p 2>/dev/null | grep -q 'handle is'; then
                        break
                    fi
                    sleep 1
                    wait_count=$((${wait_count:-0} + 1))
                done

                if [ "${wait_count:-0}" -ge "${max_wait:-60}" ]; then
                    warn "  Pythia CLI did not become ready within ${max_wait}s"
                fi

                tmux send-keys -t "$PYTHIA_SESSION" "$PYTHIA_PROMPT" Enter
                sleep 1
                tmux send-keys -t "$PYTHIA_SESSION" "" Enter

                ok "  Pythia spawned: $PYTHIA_SESSION"
                info "  Attach: tmux attach -t $PYTHIA_SESSION"
            fi
        fi
    fi

    # --- Main Claude (--spawn-all only) ---
    if [[ "$SPAWN_ALL" == "true" ]]; then
        CLAUDE_SESSION=$(tmux_session_name "claude")

        if tmux has-session -t "$CLAUDE_SESSION" 2>/dev/null; then
            warn "  tmux session '$CLAUDE_SESSION' already exists."
            if confirm "Kill existing session?"; then
                run tmux kill-session -t "$CLAUDE_SESSION"
            else
                warn "  Skipping Claude spawn."
                SPAWN_ALL=false
            fi
        fi

        if [[ "$SPAWN_ALL" == "true" ]]; then
            info "  Spawning Claude..."
            if [[ "$DRY_RUN" == "true" ]]; then
                echo -e "  ${YELLOW}[DRY-RUN]${NC} tmux new-session -d -s $CLAUDE_SESSION"
                echo -e "  ${YELLOW}[DRY-RUN]${NC} → nbs-claude"
            else
                tmux new-session -d -s "$CLAUDE_SESSION" -c "$PROJECT_ROOT"
                sleep 2
                # SECURITY RISK (Violation 2): See comment in Scribe spawn above.
                tmux send-keys -t "$CLAUDE_SESSION" "nbs-claude --dangerously-skip-permissions" Enter

                ok "  Claude spawned: $CLAUDE_SESSION"
                info "  Attach: tmux attach -t $CLAUDE_SESSION"
            fi
        fi
    fi

    # Publish spawn event
    # Violation 6 (BUG): Replace || true with proper error handling — log warning but continue.
    if [[ "$DRY_RUN" != "true" ]]; then
        if ! nbs-bus publish .nbs/events/ nbs-chat-init ai-spawned normal \
            "AI instances spawned by nbs-chat-init" >/dev/null 2>&1; then
            warn "nbs-bus publish failed for ai-spawned event (non-fatal, continuing)"
        fi
    fi
fi

# ============================================================
# Summary
# ============================================================

echo ""
echo -e "${BOLD}=== NBS Init Complete ===${NC}"
echo ""
echo "  Project:    $PROJECT_NAME"
echo "  Chat name:  $CHAT_NAME"
echo "  Root:       $PROJECT_ROOT"
echo "  Project ID: $PROJECT_ID"
echo ""
echo "  Components:"
echo "    Bus:        .nbs/events/"
echo "    Chat:       $CHAT_FILE"
echo "    Scribe log: $SCRIBE_LOG"
echo "    Config:     .nbs/events/config.yaml"

if [[ "$SPAWN_SCRIBE" == "true" ]] || [[ "$SPAWN_PYTHIA" == "true" ]] || [[ "$SPAWN_ALL" == "true" ]]; then
    echo ""
    echo "  Tmux sessions:"
    if [[ "$SPAWN_SCRIBE" == "true" ]]; then
        echo "    Scribe: $(tmux_session_name scribe)"
    fi
    if [[ "$SPAWN_PYTHIA" == "true" ]]; then
        echo "    Pythia: $(tmux_session_name pythia)"
    fi
    if [[ "$SPAWN_ALL" == "true" ]]; then
        echo "    Claude: $(tmux_session_name claude)"
    fi
    echo ""
    echo "  List all NBS sessions: tmux ls | grep nbs-"
fi

echo ""
echo "  Next steps:"
echo "    1. Join the chat:  nbs-chat-terminal $CHAT_FILE <your-handle>"
echo "    2. Start Claude:   cd $PROJECT_ROOT && nbs-claude"
echo "    3. Join (new agent): NBS_HANDLE=<name> nbs-claude"
echo ""
